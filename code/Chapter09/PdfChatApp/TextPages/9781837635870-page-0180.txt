Chapter 3 161 The order in which you catch exceptions is important. The correct order is related to the inheritance hierarchy of the exception types. You will learn about inheritance in Chapter 5, Building Your Own Types with Object-Oriented Programming. However, don’t worry too much about this—the compiler will give you build errors if you get exceptions in the wrong order anyway. Good Practice: Avoid over-catching exceptions. They should often be allowed to propagate up the call stack to be handled at a level where more information is known about the circumstances that could change the logic of how they should be handled. You will learn about this in Chapter 4, Writing, Debugging, and Testing Functions. Catching with filters You can also add filters to a catch statement using the when keyword, as shown in the following code: Write("Enter an amount: "); string amount = ReadLine()!; if (string.IsNullOrEmpty(amount)) return; try { decimal amountValue = decimal.Parse(amount); WriteLine($"Amount formatted as currency: {amountValue:C}"); } catch (FormatException) when (amount.Contains("$")) { WriteLine("Amounts cannot use the dollar sign!"); } catch (FormatException) { WriteLine("Amounts must only contain digits!"); } Checking for overflow Earlier, we saw that when casting between number types, it was possible to lose information, for example, when casting from a long variable to an int variable. If the value stored in a type is too big, it will overflow. Throwing overflow exceptions with the checked statement The checked statement tells .NET to throw an exception when an overflow happens instead of allowing it to happen silently, which is done by default for performance reasons. 