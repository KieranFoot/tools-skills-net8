Chapter 11 617 Figure 11.6: A tricky LINQ and Task code teaser from Amichai Mantinband By this point in this chapter, I would hope that you understand the LINQ parts of this tricky question. Donâ€™t worry! I would not expect you to understand the subtleties of multi-threading with tasks. It is still worth breaking down the code to make sure you understand the LINQ parts, as shown in Table 11.5: Code Description Enumerable.Range(0, 2) Returns a sequence of two integers, 0 and 1. In production code, you should add named parameters to make this clearer, as shown in the following code: Enumerable.Range(start: 0, count: 2). Select(_ => Task. Creates a task with its own thread for each of the two numbers. The _ Run(...) parameter discards the number value. Each task outputs a star * to the console. await Task. Blocks the main thread until both of the two tasks have completed. So, WhenAll(tasks); at this point, we know that two stars ** have been output to the console. tasks.Count() For the LINQ Count() extension method to work in this scenario, it must enumerate the sequence. This triggers the two tasks to execute again! But we do not know when those two tasks will execute. The value 2 is returned from the method call. Console.WriteLine( 2 stars! is output to the console. $"... stars!"); Table 11.5: Code teaser steps explanation So, we know that ** is output to the console first, then one or both tasks might output their star, then 2 stars! is output, and finally one or both tasks might output their star if they did not have time to do so before, or the main thread might end, terminating the console app before either task can output their star: **[each task could output * here]2 stars![each task could output * here] 