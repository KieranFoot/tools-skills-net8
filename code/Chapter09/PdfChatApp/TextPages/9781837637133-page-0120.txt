Chapter 3 87 A simple way of adding more smarts to your model is to apply annotation attributes, as shown in Table 3.1: Attribute Description [Required] Ensures the value is not null. [StringLength(50)] Ensures the value is up to 50 characters in length. [RegularExpression(expression)] Ensures the value matches the specified regular expression. [Column(TypeName = "money", Specifies the column type and column name used in the Name = "UnitPrice")] table. Table 3.1: Common EF Core annotation attributes For example, in the database, the maximum length of a product name is 40, and the value cannot be null, as shown highlighted in the following partial DDL code, which defines how to create a table Products: named CREATE TABLE Products ( ProductId INTEGER PRIMARY KEY, ProductName NVARCHAR (40) NOT NULL, SupplierId "INT", ... ); In a Product class, we could apply attributes to specify this, as shown in the following code: [Required] [StringLength(40)] public string ProductName { get; set; } Good Practice: If you have nullability checks enabled, then you do not need to decorate a non-nullable reference type with the [Required] attribute as shown above. This is because the C# nullability will flow to the EF Core model. A string property will be required; a string? property will be optional, in other words, nullable. You can read more about this at the following link: https://learn.microsoft.com/en-us/ef/core/ modeling/entity-properties?tabs=data-annotations%2Cwith-nrt#required-and- optional-properties. When there isnâ€™t an obvious map between .NET types and database types, an attribute can be used. For example, in the database, the column type of UnitPrice for the Products table is money. .NET does not have a money type, so it should use decimal instead, as shown in the following code: [Column(TypeName = "money")] public decimal? UnitPrice { get; set; } 