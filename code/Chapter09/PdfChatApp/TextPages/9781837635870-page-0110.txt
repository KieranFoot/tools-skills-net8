Chapter 2 91 Exceptions are a way to indicate that something has gone wrong at runtime. You will learn more about them and how to handle them in Chapter 3, Controlling Flow, Converting Types, and Handling Exceptions. Dynamic types are most useful when interoperating with non-.NET systems. For example, you might need to work with a class library written in F#, Python, or some JavaScript. You might also need to interop with technologies like the Component Object Model (COM), for example, when automating Excel or Word. Declaring local variables Local variables are declared inside methods, and they only exist during the execution of that method. Once the method returns, the memory allocated to any local variables is released. Strictly speaking, value types are released while reference types must wait for garbage collection. You will learn about the difference between value types and reference types and how to make sure that only one garbage collection is needed rather than two when releasing unmanaged resources in Chapter 6, Implementing Interfaces and Inheriting Classes. Specifying the type of a local variable Let’s explore local variables declared with specific types and using type inference: • Type statements to declare and assign values to some local variables using specific types, as shown in the following code: int population = 67_000_000; // 67 million in UK. double weight = 1.88; // in kilograms. decimal price = 4.99M; // in pounds sterling. string fruit = "Apples"; // string values use double-quotes. char letter = 'Z'; // char values use single-quotes. bool happy = true; // Booleans can only be true or false. Depending on your code editor and color scheme, it will show green squiggles under each of the variable names and lighten their text color to warn you that the variable is assigned but its value is never used. Inferring the type of a local variable You can use the var keyword to declare local variables with C# 3 and later. The compiler will infer the type from the value that you assign after the assignment operator, =. This happens at compile time so using var has no effect on runtime performance. A literal number without a decimal point is inferred as an int variable, that is, unless you add a suffix, as described in the following list: • L: Compiler infers long • UL: Compiler infers ulong • M: Compiler infers decimal 