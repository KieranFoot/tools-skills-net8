Writing, Debugging, and Testing Functions 180 // Alternatively, call the function in the interpolated string. // WriteLine($"You must pay {CalculateTax(amount: 149, // twoLetterRegionCode: "FR"):C} in tax."); 5. Run the code, view the result, and note that it uses US English culture, meaning US dollars for the currency, as shown in the following output: CurrentCulture: English (United States) You must pay $29.80 in tax. 6. In Program.cs, change the ConfigureConsole method to use your local computer culture, as shown in the following code: ConfigureConsole(useComputerCulture: true); 7. Run the code, view the result, and note that the currency should now show your local currency. For example, for me in the UK, I would see £29.80, as shown in the following output: CurrentCulture: English (United Kingdom) You must pay £29.80 in tax. 8. In Program.cs, change the ConfigureConsole method to use French culture, as shown in the following code: ConfigureConsole(culture: "fr-FR"); 9. Run the code, view the result, and note that the currency should now show Euros, as used in France, as shown in the following output: CurrentCulture: French (France) You must pay 29,80 € in tax. Can you think of any problems with the CalculateTax function as written? What would happen if the user entered a code such as fr or UK? How could you rewrite the function to improve it? Would using switch statement instead of a switch expression be clearer? a Converting numbers from cardinal to ordinal Numbers that are used to count are called cardinal numbers, for example, 1, 2, and 3, whereas numbers used to order are ordinal numbers, for example, 1st, 2nd, and 3rd. Let’s create a function to convert cardinals to ordinals: 1. In Program.Functions.cs, write a function named CardinalToOrdinal that converts a cardinal uint value into an ordinal string value; for example, it converts 1 into "1st", 2 into "2nd", and so on, as shown in the following code: static string CardinalToOrdinal(uint number) { uint lastTwoDigits = number % 100; 