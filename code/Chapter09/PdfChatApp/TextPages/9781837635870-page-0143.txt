Controlling Flow, Converting Types, and Handling Exceptions 124 For x & y, only the 2-bit column is set. For x | y, the 8, 4 and 2-bit columns are set. For x ^ y, the 8 and 4 columns are set. 3. In Program.cs, add statements to output the results of applying the left-shift operator to move the bits of the variable a by three columns, multiplying a by 8, and right-shifting the bits of the variable b by one column, as shown in the following code: // Left-shift x by three bit columns. WriteLine($"x << 3 | {x << 3,7} | {x << 3:B8}"); // Multiply x by 8. WriteLine($"x * 8 | {x * 8,7} | {x * 8:B8}"); // Right-shift y by one bit column. WriteLine($"y >> 1 | {y >> 1,7} | {y >> 1:B8}"); 4. Run the code and note the results, as shown in the following output: x << 3 | 80 | 01010000 x * 8 | 80 | 01010000 y >> 1 | 3 | 00000011 The 80 result is because the bits in it were shifted three columns to the left, so the 1 bits moved into the 64- and 16-bit columns, and 64 + 16 = 80. This is the equivalent of multiplying by 8, but CPUs can 3 result is because the 1 bits in b were shifted one column into the 2- perform a bit-shift faster. The and 1-bit columns. Good Practice: Remember that when operating on integer values, the & and | symbols are bitwise operators, and when operating on Boolean values like true and false, the & and | symbols are logical operators. Miscellaneous operators nameof and sizeof are convenient operators when working with types: • nameof returns the short name (without the namespace) of a variable, type, or member as a string value, which is useful when outputting exception messages. sizeof returns the size in bytes of simple types, which is useful for determining the efficiency • of data storage. Technically, the sizeof operator requires an unsafe code block but the sizes of value types with a C# alias, like int and double, are hardcoded as constants by the compiler so they do not need an unsafe block. 