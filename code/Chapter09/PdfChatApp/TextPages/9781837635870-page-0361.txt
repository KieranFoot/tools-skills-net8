Implementing Interfaces and Inheriting Classes 342 Now letâ€™s look at language features to work with null values that change the behavior of your code and work well as a complement to NRTs. Checking for null Checking whether a nullable reference type or nullable value type variable currently contains null is important because if you do not, a NullReferenceException can be thrown, which results in an error. You should check for a null value before using a nullable variable, as shown in the following code: // Check that the variable is not null before using it. if (thisCouldBeNull != null) { // Access a member of thisCouldBeNull. int length = thisCouldBeNull.Length; ... } C# 7 introduced is combined with the ! (not) operator as an alternative to !=, as shown in the fol- lowing code: if (!(thisCouldBeNull is null)) { C# 9 introduced is not as an even clearer alternative, as shown in the following code: if (thisCouldBeNull is not null) { Good Practice: Although you traditionally would use the expression (thisCouldBeNull != null), this is no longer considered good practice because the developer could have overloaded the != operator to change how it works. Using pattern matching with is null and is not null are the only guaranteed ways to check for null. For many developers it is still instinctual to use !=, so I apologize in advance if you catch me still using it! If you try to use a member of a variable that might be null, use the null-conditional operator, ?., as shown in the following code: string authorName = null; int? authorNameLength; // The following throws a NullReferenceException. authorNameLength = authorName.Length; // Instead of throwing an exception, null is assigned. authorNameLength = authorName?.Length; 