Chapter 2 75 5. The foreach loop iterates over each assembly name in the referenced assemblies of the entry point assembly. Assembly.Load(name) loads an assembly given the assembly name. This allows you to interact 6. with the assembly programmatically. methodCount is declared and initialized to 0. This is used to count the total 7. A counter variable number of methods in the assembly. foreach loop then iterates over each type in the assembly. 8. Another nested (t.GetMethods().Length) and adds it to the 9. For each type, it gets the number of methods methodCount. Finally, the number of types and their methods in the assembly are output to the console 10. using WriteLine(). The {0:N0} format specifier in the string is a placeholder for a number 0 refers to the argument index, N is for number format, and 0 after N specifies the number ( of decimal places). So, in essence, this script counts how many types and methods exist in each assembly referenced by the application. This might be useful to understand the complexity or size of the dependencies the application has.” And now back to the flesh and blood Mark: That’s a pretty good explanation with no mistakes or hal- lucinations! Good Practice: Tools like GitHub Copilot and ChatGPT are especially useful for program- mers when they are learning new things. And a good programmer is always learning new things! These tools are not just for writing code for you. They can explain existing code written by others and even suggest improvements. Working with variables All applications process data. Data comes in, data is processed, and then data goes out. Data usually comes into our program from files, databases, or user input, and it can be put temporarily into variables, which will be stored in the memory of the running program. When the program ends, the data in memory is lost. Data is usually output to files and databases, or to the screen or a printer. When using variables, you should think about, firstly, how much space the variable takes up in the memory, and, secondly, how fast it can be processed. We control this by picking an appropriate type. You can think of simple common types such as int and double as being different-sized storage boxes, where a smaller box would take less memory but may not be as fast at being processed; for example, adding 16-bit numbers might not be processed as quickly as adding 64-bit numbers on a 64-bit operating system. Some of these boxes may be stacked close by, and some may be thrown into a big heap further away. 