Chapter 12 531 .AddFiltering() .AddSorting() .RegisterDbContext<NorthwindContext>() .AddQueryType<Query>(); Then, decorate a query method that returns IQueryable<T> with the [UseSorting] attribute, as high- lighted in the following code: [UseFiltering] [UseSorting] public IQueryable<Product> GetProducts(NorthwindContext db) => db.Products.Include(p => p.Category); In a query, apply one or more sort orders, as shown in the following code: query ProductsSortedByMostExpensive { products(order: [ { unitPrice: DESC } ]) { productId productName unitPrice } } has two values, as shown in the following code: SortEnumType enum SortEnumType { ASC DESC } I will leave adding sorting capabilities to your GraphQL service to you. Building .NET clients for a GraphQL service Now that we have explored some queries with the Banana Cake Pop tool, letâ€™s see how a client could call the GraphQL service. Although the Banana Cake Pop tool is convenient, it runs in the same domain as the service, so some issues might not become apparent until we create a separate client. Choosing GraphQL request formats Most GraphQL services process GET and POST requests in either the application/graphql or application/json media formats. An application/graphql request would only contain a query doc- ument. The benefit of using application/json is that as well as the query document, you can specify operations when you have more than one, and define and set variables, as shown in the following code: { "query": "...", 