Chapter 8 455 Let’s see an example: 1. In Program.cs, add statements to convert the keywords dictionary into an immutable dictionary and then add a new keyword definition to it by randomly generating GUID values, as shown in the following code: ImmutableDictionary<string, string> immutableKeywords = keywords.ToImmutableDictionary(); // Call the Add method with a return value. ImmutableDictionary<string, string> newDictionary = immutableKeywords.Add( key: Guid.NewGuid().ToString(), value: Guid.NewGuid().ToString()); OutputCollection("Immutable keywords dictionary", immutableKeywords); OutputCollection("New keywords dictionary", newDictionary); 2. Run the code, view the result, and note that the immutable keywords dictionary does not get modified when you call the Add method on it; instead, it returns a new dictionary with all the existing keywords plus the newly added keyword, as shown in the following output: Immutable keywords dictionary: [float, Single precision floating point number] [long, 64-bit integer data type] [int, 32-bit integer data type] New keywords dictionary: [d0e099ff-995f-4463-ae7f-7b59ed3c8d1d, 3f8e4c38-c7a3-4b20-acb3- 01b2e3c86e8c] [float, Single precision floating point number] [long, 64-bit integer data type] [int, 32-bit integer data type] Newly added items will not always appear at the top of the dictionary as shown in my out- put above. Internally, the order is defined by the hash of the key. This is why dictionaries are sometimes called hash tables. Good Practice: To improve performance, many applications store a shared copy of com- monly accessed objects in a central cache. To safely allow multiple threads to work with those objects knowing they won’t change, you should make them immutable or use a con- current collection type, which you can read about at the following link: https://learn. microsoft.com/en-us/dotnet/api/system.collections.concurrent. 