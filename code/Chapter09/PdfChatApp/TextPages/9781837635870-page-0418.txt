Chapter 7 399 { return collection2.Count; } int num = 0; using IEnumerator<TSource> enumerator = source.GetEnumerator(); while (enumerator.MoveNext()) { num = checked(num + 1); } return num; } Good Practice: You will often see LinkedIn posts and blog articles warning you to always use the Count property of a sequence instead of calling the LINQ Count() extension method. As you can see above, this advice is unnecessary because the Count() method always checks if the sequence implements ICollection<T> or ICollection and then uses the Count property anyway. What it doesnâ€™t do is check if the sequence is an array and then use the Length property. If you have an array of any type, avoid Count() in favor of the Length property. The final part of the Count method implementation shows how the foreach state- ment works internally. It calls the GetEnumerator method and then calls the MoveNext method in a while loop. To calculate the count, the loop increments an int value. It does all this in a checked statement so that an exception will be thrown in the case of an overflow. The Count method can, therefore, only count sequences with up to about 2 billion items. 18. In the ILSpy toolbar, click the Select language to decompile dropdown and select IL, and then review the IL source code of the Count method. To save two pages in this book, I have not shown the code here. Good Practice: The IL code is not especially useful unless you get very advanced with C# and .NET development, when knowing how the C# compiler translates your source code into IL code can be important. The much more useful edit win- dows contain the equivalent C# source code written by Microsoft experts. You can learn a lot of good practices from seeing how professionals implement types. For example, the Count method shows how to check arguments for null. 19. Close ILSpy. 