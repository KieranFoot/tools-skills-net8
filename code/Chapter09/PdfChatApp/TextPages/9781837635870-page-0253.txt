Building Your Own Types with Object-Oriented Programming 234 <Nullable>enable</Nullable> <ImplicitUsings>enable</ImplicitUsings> </PropertyGroup> <ItemGroup> <Using Include="System.Console" Static="true" /> </ItemGroup> </Project> Although we can use the C# 12 compiler, some modern compiler features require a modern .NET runtime. For example, we cannot use default implementations in an interface (introduced in C# 8) because it requires .NET Standard 2.1. We cannot use the required keyword (introduced in C# 11) because it requires an attribute introduced in .NET 7. But many useful modern compiler features, like raw literal strings, will be available to us. 4. Save and close the file. Class1.cs. 5. Delete the file named 6. Compile the project so that other projects can reference it later: • In Visual Studio 2022, navigate to Build | Build PacktLibraryNetStandard2. dotnet build. • In Visual Studio Code, enter the following command: Good Practice: To use all the latest C# language and .NET platform features, put types in a .NET 8 class library. To support legacy .NET platforms like .NET Core, .NET Framework, and Xamarin, put types that you might reuse in a .NET Standard 2.0 class library. By de- fault, targeting .NET Standard 2.0 uses the C# 7 compiler, but this can be overridden so you get the benefits of the newer SDK and compiler even though you are limited to .NET Standard 2.0 APIs. Understanding file-scoped namespaces Traditionally, you define types like a class nested in a namespace, as shown in the following code: namespace Packt.Shared { public class Person { } } 