Chapter 5 279 { return Children.Find(p => p.Name == name); } } You will learn more about collections like List<T> in Chapter 8, Working with Common .NET Types, and how to write lambda expressions using => in Chapter 11, Querying and Manipulating Data Using LINQ. 3. In Program.cs, add statements to add two children to Sam, and then access the first and sec- Children field and the shorter indexer syntax, as shown in the ond children using the longer following code: sam.Children.Add(new() { Name = "Charlie", Born = new(2010, 3, 18, 0, 0, 0, TimeSpan.Zero) }); sam.Children.Add(new() { Name = "Ella", Born = new(2020, 12, 24, 0, 0, 0, TimeSpan.Zero) }); // Get using Children list. WriteLine($"Sam's first child is {sam.Children[0].Name}."); WriteLine($"Sam's second child is {sam.Children[1].Name}."); // Get using the int indexer. WriteLine($"Sam's first child is {sam[0].Name}."); WriteLine($"Sam's second child is {sam[1].Name}."); // Get using the string indexer. WriteLine($"Sam's child named Ella is {sam["Ella"].Age} years old."); 4. Run the PeopleApp project and view the result, as shown in the following output: Sam's first child is Charlie. Sam's second child is Ella. Sam's first child is Charlie. Sam's second child is Ella. Sam's child named Ella is 3 years old. Pattern matching with objects In Chapter 3, Controlling Flow, Converting Types, and Handling Exceptions, you were introduced to basic pattern matching. In this section, we will explore pattern matching in more detail. 