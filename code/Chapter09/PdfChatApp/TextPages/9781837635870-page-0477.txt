Working with Common .NET Types 458 Good practice with collections Since .NET 1.1, types like StringBuilder have had a method named EnsureCapacity that can presize its internal storage array to the expected final size of the string. This improves performance because it does not have to repeatedly increment the size of the array as more characters are appended. Since .NET Core 2.1, types like Dictionary<T> and HashSet<T> have also had EnsureCapacity. In .NET 6 and later, collections like List<T>, Queue<T>, and Stack<T> now have an EnsureCapacity method too, as shown in the following code: List<string> names = new(); names.EnsureCapacity(10_000); // Load ten thousand names into the list. Letâ€™s say you need to create a method to process a collection. For maximum flexibility, you could declare the input parameter to be IEnumerable<T> and make the method generic, as shown in the following code: void ProcessCollection<T>(IEnumerable<T> collection) { // Process the items in the collection, // perhaps using a foreach statement. } I could pass an array, a list, a queue, or a stack, containing any type, like int, string, Person, or any- thing else that implements IEnumerable<T>, into this method and it will process the items. However, the flexibility to pass any collection to this method comes at a performance cost. One of the performance problems with IEnumerable<T> is also one of its benefits: deferred execution, also known as lazy loading. Types that implement this interface do not have to implement deferred execution, but many do. But the worst performance problem with IEnumerable<T> is that the iteration must allocate an object on the heap. To avoid this memory allocation, you should define your method using a concrete type, as shown highlighted in the following code: void ProcessCollection<T>(List<T> collection) { // Process the items in the collection, // perhaps using a foreach statement. } This will use the List<T>.Enumerator GetEnumerator() method, which returns a struct, instead of the IEnumerator<T> GetEnumerator() method, which returns a reference type. Your code will be two to three times faster and require less memory. As with all recommendations related to performance, you should confirm the benefit by running performance tests on your actual code in a product environment. 