Chapter 6 305 Note that three items have a unique integer key to look them up. The last item has a Person object as its key to look it up. This is valid in a non-generic collection. 2. Add statements to define a key with the value of 2 and use it to look up its value in the hash table, as shown in the following code: int key = 2; // Look up the value that has 2 as its key. WriteLine(format: "Key {0} has value: {1}", arg0: key, arg1: lookupObject[key]); 3. Add statements to use the harry object to look up its value, as shown in the following code: // Look up the value that has harry as its key. WriteLine(format: "Key {0} has value: {1}", arg0: harry, arg1: lookupObject[harry]); 4. Run the PeopleApp project and note that it works, as shown in the following output: Key 2 has value: Beta Key Packt.Shared.Person has value: Delta Although the code works, there is potential for mistakes because literally any type can be used for the key or value. If another developer used your variable named and expected all the items to be a certain type, they might cast them to that type and get exceptions because some values might be a different type. A lookup object with lots of items would also give poor performance. Good Practice: Avoid types in the System.Collections namespace. Use types in the System.Collections.Generics and related namespaces instead. If you need to use a library that uses non-generic types, then of course you will have to use non-generic types. This is an example of what is commonly referred to as technical debt. Working with generic types System.Collections.Generic.Dictionary<TKey, TValue> can be used to store multiple values, each with a unique key that can later be used to quickly look up its value. Both the key and value can be any object, but you must tell the compiler what the types of the key and value will be when you first instantiate the collection. You do this by specifying types for the generic parameters in angle brackets <>, TKey, and TValue. 