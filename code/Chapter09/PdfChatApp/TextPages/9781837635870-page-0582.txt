Chapter 10 563 EF Core can only track entities with keys because it uses the key to uniquely identify the entity in the database. Keyless entities, like those returned by views, are never tracked in any scenario. In the Northwind database, in the Customers table, there is a customer, as shown in the following record: CustomerId: ALFKI CompanyName: Alfreds Futterkiste Country: Germany Phone: 030-0074321 If you execute a query within a data context, like getting all customers in Germany, and then execute another query within the same data context, like getting all customers whose name starts with A, if one of those customer entities already exists in the context, it will be identified and not loaded again, which improves performance. However, if the telephone number of that customer is updated in the database between the executions of the two queries, then the entity being tracked in the data context is not refreshed with the new telephone number. If you do not need to track local changes, or you want to load new instances of an entity for every query execution with the latest data values, even if the entity is already loaded, then you can disable tracking. To disable tracking for an individual query, call the AsNoTracking method as part of the query, as shown in the following code: var products = db.Products .AsNoTracking() .Where(p => p.UnitPrice > price) .Select(p => new { p.ProductId, p.ProductName, p.UnitPrice }); To disable tracking by default for an instance of a data context, set the change trackerâ€™s query-tracking behavior to NoTracking, as shown in the following code: db.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking; To disable tracking for an individual query but retain identity resolution, call the AsNoTrackingWith method as part of the query, as shown in the following code: IdentityResolution var products = db.Products .AsNoTrackingWithIdentityResolution() .Where(p => p.UnitPrice > price) .Select(p => new { p.ProductId, p.ProductName, p.UnitPrice }); 