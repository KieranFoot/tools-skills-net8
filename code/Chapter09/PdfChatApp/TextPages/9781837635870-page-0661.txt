Introducing Web Development Using ASP.NET Core 642 5. Build the two class libraries and fix any compiler errors. Registering the scope of a dependency service By default, a DbContext class is registered using the Scope lifetime, meaning that multiple threads can share the same instance. But DbContext does not support multiple threads. If more than one thread NorthwindContext class instance at the same time, then you will see the attempts to use the same following runtime exception thrown: A second operation started on this context before a previous operation completed. This is usually caused by different threads using the same instance of a DbContext, however instance members are not guaranteed to be thread safe. This happens in Blazor projects with components set to run on the server side because, whenever in- teractions on the client side happen, a SignalR call is made back to the server where a single instance of the database context is shared between multiple clients. This issue does not occur if a component is set to run on the client side. Creating class libraries for entity models using SQL Server If you would like to use SQL Server instead of SQLite, then there are instructions at the following link: https://github.com/markjprice/cs12dotnet8/blob/main/docs/sql-server/README.md#chapter- 12---introducing-web-development-using-aspnet-core Improving the class-to-table mapping The dotnet-ef command-line tool generates different code for SQL Server and SQLite because they support different levels of functionality, and SQLite uses dynamic typing. For example, with EF Core 7, all integer columns in SQLite were mapped to nullable long properties for maximum flexibility. With EF Core 8 and later, the actual stored values are checked and if they are all storable in an int, it int. If they are all column values storable in a short, it will will declare the mapped property as an short. declare the mapped property as a In this edition, we need to do less work to improve the mapping. Hooray! As another example, SQL Server text columns can have limits on the number of characters. SQLite does not support this. So, dotnet-ef will generate validation attributes to ensure string properties are limited to a specified number of characters for SQL Server but not for SQLite, as shown in the following code: // SQLite database provider-generated code. [Column(TypeName = "nvarchar (15)")] public string CategoryName { get; set; } = null!; // SQL Server database provider-generated code. [StringLength(15)] public string CategoryName { get; set; } = null!; 