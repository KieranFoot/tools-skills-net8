Chapter 6 323 void Play(); void Pause(); void Stop() // Default interface implementation. { WriteLine("Default implementation of Stop."); } } 2. Build the PeopleApp project, and note that the projects compile successfully despite the DvdPlayer class not implementing Stop. In the future, we could override the default imple- mentation of Stop by implementing it in the DvdPlayer class. Although controversial, default implementations in interfaces might be useful in scenarios where the most common implementation is known at the time of defining the interface. Therefore, it is best if the interface defines that implementation once, and then most types that implement that interface can inherit it without needing to implement their own. However, if the interface definer does not know how the member should or even could be implemented, then it is a waste of effort to add a default implementation because it will always be replaced. Think about the IComparable interface that you saw earlier in this chapter. It defines a CompareTo method. What might a default implementation of that method be? Personally, I think it’s obvious that there is no default implementation that would make any practical sense. The least-worst implementa- tion that I can think of would be to compare the string values returned from calling ToString on the two objects. However, every type really should implement its own CompareTo method. You are likely to find the same with 99.9% of the interfaces you use. Now let’s look at how types are stored in a computer’s memory. Managing memory with reference and value types I mentioned reference types a couple of times. Let’s look at them in more detail. Understanding stack and heap memory There are two categories of memory: stack memory and heap memory. With modern operating sys- tems, the stack and heap can be anywhere in physical or virtual memory. Stack memory is faster to work with but limited in size. It is fast because it is managed directly by the CPU and it uses a last-in, first-out mechanism, so it is more likely to have data in its L1 or L2 cache. Heap memory is slower but much more plentiful. On Windows, for ARM64, x86, and x64 machines, the default stack size is 1 MB. It is 8 MB on a typical modern Linux-based operating system. For example, in a macOS or Linux terminal, I can enter the command ulimit -a to discover that the stack size is limited to 8,192 KB and that other memory is “unlimited.” This limited amount of stack memory is why it is so easy to fill it up and get a “stack overflow.” 