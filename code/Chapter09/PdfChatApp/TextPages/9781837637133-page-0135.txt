Building Entity Models for SQL Server Using EF Core 102 Understand how the three tracking choices work and select the best for your data context or individual queries. In the next topic, you will learn how to map inheritance hierarchies. Mapping inheritance hierarchies with EF Core Imagine that you have an inheritance hierarchy for some C# classes to store information about stu- dents and employees, both of which are types of people. All people have a name and an ID to uniquely identify them, students have a subject they are studying, and employees have a hire date, as shown in the following code: public abstract class Person { public int Id { get; set; } public string? Name { get; set; } } public class Student : Person { public string? Subject { get; set; } } public class Employee : Person { public DateTime HireDate { get; set; } } By default, EF Core will map these to a single table using the table-per-hierarchy (TPH) mapping strategy. EF Core 5 introduced support for the table-per-type (TPT) mapping strategy. EF Core 7 intro- duced support for the table-per-concrete-type (TPC) mapping strategy. Letâ€™s explore the differences between these mapping strategies. Table-per-hierarchy (TPH) mapping strategy For the Person-Student-Employee hierarchy, TPH will use a single table structure with a discriminator column to indicate which type of person, a student or employee, the row is, with nullable columns for extra values that only apply to some of the types, as shown highlighted in the following code: CREATE TABLE [People] ( [Id] int NOT NULL IDENTITY, [Name] nvarchar(max) NOT NULL, [Discriminator] nvarchar(max) NOT NULL, [Subject] nvarchar(max) NULL, [HireDate] nvarchar(max) NULL, CONSTRAINT [PK_People] PRIMARY KEY ([Id]) ); 