Chapter 2 75 Generating objects with a data reader For maximum flexibility, we likely want to convert the rows in a data reader into object instances stored in an array or collection. After that, we could serialize the object graph however we want. ADO.NET does not have a built-in ability to map a data reader row to an object, so we will have to do it manually. Letâ€™s see an example: 1. Add a new class file named Product.cs, and modify its contents to define a class to represent just the three columns we want from each row in the Products table, as shown in the following code: namespace Northwind.Models; public class Product { public int ProductId { get; set; } public string? ProductName { get; set; } public decimal? UnitPrice { get; set; } } Good Practice: In this task, we will use this type only for read-only instances, so we could have used an immutable record. But later we will need to change property values after the object is created, so we have to define a class instead. 2. At the top of Program.cs, import the Northwind.Models namespace so we can use Product. In Program.cs, before creating the file stream, instantiate a list of products with an initial 3. storage for 77 items (but this is not a limit) because when first created the Northwind database has 77 products, as shown highlighted in the following code: List<Product> products = new(capacity: 77); await using (FileStream jsonStream = File.Create(jsonPath)) 4. In the while block, add statements to instantiate the Product type per row in the data reader and add it to the list, as shown highlighted in the following code: while (await r.ReadAsync()) { Product product = new() { ProductId = await r.GetFieldValueAsync<int>("ProductId"), ProductName = await r.GetFieldValueAsync<string>("ProductName"), UnitPrice = await r.GetFieldValueAsync<decimal>("UnitPrice") }; 