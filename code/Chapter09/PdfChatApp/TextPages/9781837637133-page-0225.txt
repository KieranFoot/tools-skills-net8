Multitasking and Concurrency 192 2. In Program.Methods.cs, in both methods A and B, inside the for statement and after modifying the string value, add a statement to safely increment the counter, as shown in the following code: Interlocked.Increment(ref SharedObjects.Counter); 3. In Program.cs, before outputting the elapsed time, write the current value of the counter to the console, as shown in the following code: WriteLine($"{SharedObjects.Counter} string modifications."); 4. Run the code and view the result, as shown highlighted in the following output: Please wait for the tasks to complete. .......... Results: BBBBBAAAAA. 10 string modifications. 13,531 elapsed milliseconds. Observant readers will realize that the existing conch object protects all shared resources accessed Interlocked in within a block of code locked by the conch, and therefore, it is unnecessary to use this specific example. But if we had not already been protecting another shared resource like Message, then using Interlocked would be necessary. Applying other types of synchronization Monitor and Interlocked are mutually exclusive locks that are simple and effective, but sometimes, you need more advanced options to synchronize access to shared resources, as shown in Table 5.3: Type Description These allow multiple threads to be in read mode, one thread to be in write mode with exclusive ownership of the write lock, and one thread ReaderWriterLock, that has read access to be in upgradeable read mode, from which the ReaderWriterLockSlim thread can upgrade to write mode without having to relinquish its read access to the resource. Like Monitor, this provides exclusive access to a shared resource, Mutex except it is used for inter-process synchronization. These limit the number of threads that can access a resource or pool Semaphore, SemaphoreSlim of resources concurrently by defining slots. This is known as resource throttling rather than resource locking. AutoResetEvent, Event wait handles allow threads to synchronize activities by signaling ManualResetEvent each other and by waiting for each otherâ€™s signals. Table 5.3: Synchronization types 