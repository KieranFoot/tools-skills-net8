Building Your Own Types with Object-Oriented Programming 286 3. In Program.cs, add statements to create two instances of AnimalClass and two instances of AnimalRecord, and then compare them for equality, as shown in the following code: AnimalClass ac1 = new() { Name = "Rex" }; AnimalClass ac2 = new() { Name = "Rex" }; WriteLine($"ac1 == ac2: {ac1 == ac2}"); AnimalRecord ar1 = new() { Name = "Rex" }; AnimalRecord ar2 = new() { Name = "Rex" }; WriteLine($"ar1 == ar2: {ar1 == ar2}"); 4. Run the PeopleApp project to view the results, and note that two class instances are not equal even if they have the same property values, and two record instances are equal if they have the same property values, as shown in the following output: ac1 == ac2: False ar1 == ar2: True Class instances are only equal if they are literally the same object. This is true when their memory addresses are equal. You will learn more about the equality of types in Chapter 6, Implementing Interfaces and Inheriting Classes. Positional data members in records The syntax for defining a record can be greatly simplified using positional data members. Instead of using object initialization syntax with curly braces, sometimes you might prefer to provide a construc- tor with positional parameters, as you saw earlier in this chapter. You can also combine this with a deconstructor to split the object into individual parts, as shown in the following code: public record ImmutableAnimal { public string Name { get; init; } public string Species { get; init; } public ImmutableAnimal(string name, string species) { Name = name; Species = species; } public void Deconstruct(out string name, out string species) 