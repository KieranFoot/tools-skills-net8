Building Your Own Types with Object-Oriented Programming 284 FirstName = "Jeff", LastName = "Winger" }; jeff.FirstName = "Geoff"; 4. Compile the console app and note the compile error, as shown in the following output: C:\cs12dotnet8\Chapter05\PeopleApp\Program.cs(404,1): error CS8852: Init-only property or indexer 'ImmutablePerson.FirstName' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor. [/Users/markjprice/Code/Chapter05/ PeopleApp/PeopleApp.csproj] 5. Comment out the attempt to set the FirstName property after instantiation. Even if you do not set FirstName in the object initializer, you still would not be able to set it post-initialization. If you need to force a property to be set, then apply the required keyword that you learned about earlier in this chapter. Defining record types Init-only properties provide some immutability to C#. You can take the concept further by using record types. These are defined by using the record keyword instead of (or as well as) the class keyword. That can make the whole object immutable, and it acts like a value when compared. We will discuss equality and comparisons of classes, records, and value types in more detail in Chapter 6, Implementing Interfaces and Inheriting Classes. Immutable records should not have any state (properties and fields) that change after instantiation. Instead, the idea is that you create new records from existing ones. The new record has the changed state. This is called non-destructive mutation. To do this, C# 9 introduced the with keyword: 1. In Records.cs, add a record named ImmutableVehicle after the ImmutablePerson class, as shown in the following code: public record ImmutableVehicle { public int Wheels { get; init; } public string? Color { get; init; } public string? Brand { get; init; } } 2. In Program.cs, add statements to create a car and then a mutated copy of it, as shown in the following code: ImmutableVehicle car = new() { 