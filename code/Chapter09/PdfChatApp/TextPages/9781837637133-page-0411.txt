Caching, Queuing, and Resilient Background Services 378 When you add an object to a cache, you should set an expiration. There are two types, absolute and sliding, and you can set one or the other, both, or neither: • Absolute expiration: This is a fixed date/time, for example, 1am on December 24, 2023. When the date/time is reached, the object is evicted. To use this, set the AbsoluteExpiration property of a cache entry to a DateTime value. Choose this if you need to guarantee that at some point the data in the cache will be refreshed. • Sliding expiration: This is a time span, for example, 20 seconds. When the time span expires, the object is evicted. However, whenever an object is read from the cache, its expiration is reset for another 20 seconds. This is why it is described as sliding. A common duration for a Content Management System (CMS), where content like a web page is loaded from a database, is 12 hours. Content frequently viewed by visitors, like the home page, is then likely to remain in memory. To use this, set the SlidingExpiration property of a cache entry to a TimeSpan value. Choose this if it is acceptable for data to potentially never be refreshed. A good CMS will have an additional mechanism to reliably force a refresh when new content is published, but this functionality is not built into .NET caching. • Both expirations: If you only set a sliding expiration, an object may stay in the cache forever, AbsoluteExpirationRelativeToNow property to a TimeSpan so you might also want to set the further in the future, after which the object should definitely be evicted. Choose this if you want the best of both worlds. CacheItemPriority.NeverRemove. • Never: You can set a cache entry to have a priority of You can also configure a method to call back to when an object is evicted from the cache. This allows you to execute some business logic to decide if you want to add the object back into the cache, perhaps after refreshing it from the original data source. You do this by calling the RegisterPostEvictionCallback method. Let’s explore the in-memory cache: 1. In the Northwind.WebApi.Service project, in Program.cs, import the namespace to work with the in-memory cache, as shown in the following code: using Microsoft.Extensions.Caching.Memory; // To use IMemoryCache and so on. 2. In Program.cs, after the call to CreateBuilder, in the section for configuring services, register an implementation for the in-memory cache, configured to store a maximum of 50 products, as shown in the following code: builder.Services.AddSingleton<IMemoryCache>(new MemoryCache( new MemoryCacheOptions { TrackStatistics = true, SizeLimit = 50 // Products. })); 