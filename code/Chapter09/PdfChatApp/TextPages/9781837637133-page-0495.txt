Building Serverless Nanoservices Using Azure Functions 462 <CopyToPublishDirectory>Never</CopyToPublishDirectory> </None> </ItemGroup> If you are using Visual Studio Code, manually add the preceding entry to the project file. 3. In the Northwind.AzureFunctions.Service project, add package references for working with the Azure Queue and Blob Storage extensions and drawing with ImageSharp, as shown in the following markup: <PackageReference Version="5.2.0" Include= "Microsoft.Azure.Functions.Worker.Extensions.Storage.Queues" /> <PackageReference Version="6.2.0" Include= "Microsoft.Azure.Functions.Worker.Extensions.Storage.Blobs" /> <PackageReference Include="SixLabors.ImageSharp" Version="3.0.2" /> <PackageReference Include="SixLabors.ImageSharp.Drawing" Version="2.0.0" /> 4. Build the project to restore packages. In the Northwind.AzureFunctions.Service project, add a new class named 5. NumbersToChecksFunction.cs. In NumbersToChecksFunction.cs, add statements to register the function with an output bind- 6. ing for Queue Storage so that it can write to a named queue, and when the amount is successfully parsed to return the words to the queue, as shown in the following code: using Humanizer; // To use ToWords extension method. using Microsoft.Azure.Functions.Worker; // To use [Function] and so on. using Microsoft.Azure.Functions.Worker.Http; // To use HttpRequestData. using Microsoft.Extensions.Logging; // To use ILogger. namespace Northwind.AzureFunctions.Service; public class NumbersToChecksFunction { private readonly ILogger _logger; public NumbersToChecksFunction(ILoggerFactory loggerFactory) { _logger = loggerFactory.CreateLogger<NumbersToChecksFunction>(); } [Function(nameof(NumbersToChecksFunction))] [QueueOutput("checksQueue")] // Return value is written to this queue. 