Chapter 3 105 [Name] nvarchar(max) NOT NULL, [HireDate] nvarchar(max) NULL, CONSTRAINT [PK_Employees] PRIMARY KEY ([Id]) CONSTRAINT [FK_Employees_People] FOREIGN KEY ([Id]) REFERENCES [People] ([Id]) ); Since there is not a single table with an IDENTITY column to assign Id values, we can use the (NEXT VALUE FOR [PersonIds]) command to define a sequence shared between the two tables so they do not assign the same Id values. Some data in the tables might look like the following: Id Name Subject 1 Roman Roy History Table 3.9: Students table Id Name HireDate 2 Kendall Roy 02/04/2014 3 Siobhan Roy 12/09/2020 Table 3.10: Employees table The main benefit of the TPC mapping strategy is performance because when querying a single con- crete type, only one table is needed so we avoid expensive joins. It works best for large inheritance hierarchies of many concrete types, each with many type-specific properties. Configuring inheritance hierarchy mapping strategies First, all types must be included in the model, as shown in the following code: public DbSet<Person> People { get; set; } public DbSet<Student> Students { get; set; } public DbSet<Employee> Employees { get; set; } For TPH, you are now finished, because it is the default! If you want to make this explicit, then in the data context class OnModelCreating method, call the appropriate “use mapping strategy” method on Person is the base class, so you would call UseTphMappingStrategy the base class of the hierarchy. on that entity type, as shown in the following code: modelBuilder.Entity<Person>().UseTphMappingStrategy(); 