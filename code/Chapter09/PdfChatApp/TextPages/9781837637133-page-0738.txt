Chapter 16 705 In XAML, this could be simplified to the following lines of code. When this XAML is processed, the equivalent properties are set, and methods are called to achieve the same goal as the preceding C# code: <HorizontalStackPanel x:Name="toolbar"> <Button x:Name="newButton" Background="Pink" Clicked="NewButton_Clicked">New</Button> <Button x:Name="openButton" Background="Pink" Clicked="OpenButton_Clicked">Open</Button> </StackPanel> You can think of XAML as an alternative and easier way of declaring and instantiating .NET types, especially when defining a UI and the resources that it uses. XAML allows resources like brushes, styles, and themes to be declared at different levels, like a UI element or a page, or globally for the application to enable resource sharing. XAML allows data binding between UI elements or between UI elements and objects and collections. If you choose to use XAML to define your UI and related resources at compile time, then the code-be- hind file must call the InitializeComponent method in the page constructor, as shown highlighted in the following code: public partial class MainPage : ContentPage { public MainPage() { InitializeComponent(); // Process the XAML markup. } private void NewButton_Clicked(object sender, EventArgs e) { ... } private void OpenButton_Clicked(object sender, EventArgs e) { ... } } Calling the InitializeComponent method tells the page to read its XAML, create the controls defined in it, and set their properties and event handlers. 