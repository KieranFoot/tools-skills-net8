Introducing Apps and Services with .NET 10 Common service principles One of the most important service architecture principles is to make method calls chunky instead of chatty. In other words, try to bundle all the data needed for an operation in a single call, rather than requiring multiple calls to transmit all that information. This is because the overhead of a remote call is one of the biggest negative effects of services. This is also why having smaller and smaller services can hugely negatively impact a solution architecture. Summary of choices for services Each service technology has its pros and cons based on its feature support, as shown in Table 1.2: Feature Web API OData GraphQL gRPC SignalR Clients can request just No Yes Yes No No the data they need Minimum HTTP version 1.1 1.1 1.1 2.0 1.1 Browser support Yes Yes Yes No Yes Data format XML, JSON XML, JSON GraphQL (JSONish) Binary Varies Service documentation Swagger Swagger No No No Third-party Third-party Google Microsoft Code generation Third-party Caching Easy Easy Hard Hard Hard Table 1.2: Pros and cons of common service technologies Use these recommendations for various scenarios as guidance, as shown in Table 1.3: Scenario Recommendation Public service HTTP/1.1-based services are best for services that need to be publicly accessible, especially if they need to be called from a browser or mobile device. Public data service OData and GraphQL are both good choices for exposing complex hierarchical datasets that could come from different data stores. OData is designed and supported by Microsoft via official .NET packages. GraphQL is designed by Facebook and supported by third-party packages. Service-to-service gRPC is designed for low-latency and high-throughput communication. gRPC is great for lightweight internal microservices where efficiency is critical. Point-to-point real-time gRPC has excellent support for bidirectional streaming. gRPC services communication can push messages in real time without polling. SignalR is designed for real-time communication of many kinds, so it tends to be easier to implement than gRPC although it is less efficient. 