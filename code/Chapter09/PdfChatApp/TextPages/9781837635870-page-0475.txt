Working with Common .NET Types 456 The generic collections have some potential performance issues related to how they are designed. First, being generic, the types of items or types used for keys and values for a dictionary have a big effect on performance depending on what they are. Since they could be any type, the .NET team cannot optimize the algorithm. string and int types are the most used in real life. If the .NET team could rely on those always being the types used, then they could greatly improve performance. Second, collections are dynamic, meaning that new items can be added, and existing items can be removed at any time. Even more optimizations could be made if the .NET team knew that no more changes would be made to the collection. .NET 8 introduces a new concept: frozen collections. Hmmm, we already have immutable collections, so what is different about frozen collections? Are they tasty and delicious like ice cream? The idea is that 95% of the time, a collection is populated and then never changed. So, if we could optimize them at the time of creation, then those optimizations could be made, adding some time and effort upfront, but then after that, performance for reading the collection could be greatly improved. In .NET 8, there are only two frozen collections: FrozenDictionary<TKey, TValue> and FrozenSet<T>. More may come in future versions of .NET, but these are the two most common scenarios that would benefit from the frozen concept. Letâ€™s go: 1. At the top of Program.cs, import the System.Collections.Frozen namespace, as shown in the following code: using System.Collections.Frozen; // To use FrozenDictionary<T, T>. 2. At the bottom of Program.cs, add statements to convert the keywords dictionary into a frozen dictionary, output its items, and then look up the definition of long, as shown in the following code: // Creating a frozen collection has an overhead to perform the // sometimes complex optimizations. FrozenDictionary<string, string> frozenKeywords = keywords.ToFrozenDictionary(); OutputCollection("Frozen keywords dictionary", frozenKeywords); // Lookups are faster in a frozen dictionary. WriteLine($"Define long: {frozenKeywords["long"]}"); 3. Run the code and view the result, as shown in the following output: Frozen keywords dictionary: [int, 32-bit integer data type] [long, 64-bit integer data type] 