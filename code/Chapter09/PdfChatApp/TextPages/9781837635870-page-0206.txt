Chapter 4 187 Local functions do not support XML comments because local functions cannot be used outside the member in which they are declared, so it makes no sense to generate documentation from them. Sadly, this also means no tooltip, which would still be useful, but neither Visual Studio 2022 nor Visual Studio Code recognize that. Good Practice: Add XML documentation comments to all your functions except local functions. Using lambdas in function implementations F# is Microsoft’s strongly typed functional-first programming language that, like C#, compiles to In- termediate Language (IL) to be executed by .NET. Functional languages evolved from lambda calculus, a computational system based only on functions. The code looks more like mathematical functions than steps in a recipe. Some of the important attributes of functional languages are defined in the following list: • Modularity: The same benefit of defining functions in C# applies to functional languages. Breaks up a large complex code base into smaller pieces. • Immutability: Variables in the C# sense do not exist. Any data value inside a function cannot change. Instead, a new data value can be created from an existing one. This reduces bugs. • Maintainability: Code is cleaner and clearer (for mathematically-inclined programmers!). Since C# 6, Microsoft has worked to add features to the language to support a more functional ap- proach, for example, adding tuples and pattern matching in C# 7, non-null reference types in C# 8, and improving pattern matching and adding records, that is, potentially immutable objects, in C# 9. In C# 6, Microsoft added support for expression-bodied function members. We will look at an example of this now. In C#, lambdas are the use of the => character to indicate a return value from a function. The Fibonacci sequence of numbers always starts with 0 and 1. Then the rest of the sequence is generated using the rule of adding together the previous two numbers, as shown in the following sequence of numbers: 0 1 1 2 3 5 8 13 21 34 55 ... The next term in the sequence would be 34 + 55, which is 89. We will use the Fibonacci sequence to illustrate the difference between an imperative and declarative function implementation: 1. In Program.Functions.cs, write a function named FibImperative, which will be written in an imperative style, as shown in the following code: static int FibImperative(uint term) { 