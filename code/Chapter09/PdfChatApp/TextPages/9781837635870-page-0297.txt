Building Your Own Types with Object-Oriented Programming 278 6. Run the PeopleApp project and note the exception, as shown in the following output: Unhandled exception. System.ArgumentException: 128 is not a member of the WondersOfTheAncientWorld enum. (Parameter 'FavoriteAncientWonder') 7. In Program.cs, set Bobâ€™s favorite wonder back to a valid single enum value. Defining indexers Indexers allow the calling code to use the array syntax to access a property. For example, the string string, as type defines an indexer so that the calling code can access individual characters in the shown in the following code: string alphabet = "abcdefghijklmnopqrstuvwxyz"; char letterF = alphabet[5]; // 0 is a, 1 is b, and so on. You can overload indexers so that different types can be used for their parameters. For example, as well as passing an int value, you could also pass a string value. We will define an indexer to simplify access to the children of a person: 1. In PersonAutoGen.cs, add statements to define an indexer to get and set a child using the index of the child, as shown in the following code: #region Indexers: Properties that use array syntax to access them. public Person this[int index] { get { return Children[index]; // Pass on to the List<T> indexer. } set { Children[index] = value; } } #endregion 2. In PersonAutoGen.cs, add statements to define an indexer to get and set a child using the name of the child, as shown in the following code: // A read-only string indexer. public Person this[string name] { get 