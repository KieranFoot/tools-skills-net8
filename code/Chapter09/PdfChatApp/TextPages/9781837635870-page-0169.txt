Controlling Flow, Converting Types, and Handling Exceptions 150 2. At the bottom of Program.cs, type statements to declare and assign a value to a double variable, convert it into an integer, and then write both values to the console, as shown in the following code: double g = 9.8; int h = ToInt32(g); // A method of System.Convert. WriteLine($"g is {g}, h is {h}"); 3. Run the code and view the result, as shown in the following output: g is 9.8, h is 10 An important difference between casting and converting is that converting rounds the double value 9.8 up to 10 instead of trimming the part after the decimal point. Another is that casting can allow overflows while converting will throw an exception. Rounding numbers and the default rounding rules You have now seen that the cast operator trims the decimal part of a real number and that the System. methods round up or down. However, what is the rule for rounding? Convert In British primary schools for children aged 5 to 11, pupils are taught to round up if the decimal part is .5 or higher and round down if the decimal part is less. Of course, these terms only make sense because at that age the pupils are only dealing with positive numbers. With negative numbers, these terms become confusing and those terms should be avoided. This is why the .NET API uses the enum values AwayFromZero, ToZero, ToEven, ToPositiveInfinity, and ToNegativeInfinity for improved clarity. Letâ€™s explore if C# follows the same primary school rule: 1. Type statements to declare and assign an array of double values, convert each of them into an integer, and then write the result to the console, as shown in the following code: double[,] doubles = { { 9.49, 9.5, 9.51 }, { 10.49, 10.5, 10.51 }, { 11.49, 11.5, 11.51 }, { 12.49, 12.5, 12.51 } , { -12.49, -12.5, -12.51 }, { -11.49, -11.5, -11.51 }, { -10.49, -10.5, -10.51 }, { -9.49, -9.5, -9.51 } }; WriteLine($"| double | ToInt32 | double | ToInt32 | double | ToInt32 |"); for (int x = 0; x < 8; x++) 