Querying and Manipulating Data Using LINQ 594 2. Replace var with the actual type, as shown highlighted in the following code: IOrderedEnumerable<string> query = names .Where(name => name.Length > 4) .OrderBy(name => name.Length) .ThenBy(name => name); Good practice: Once you have finished working on a query, you could change the declared type from var to the actual type to make it clearer what the type is. This is easy because your code editor can tell you what it is. Doing this is just for clarity. It has no effect on performance because C# changes all var declarations to the actual types at compile time. 3. Run the code and note that it has the same behavior. Filtering by type The Where extension method is great for filtering by values, such as text and numbers. But what if the sequence contains multiple types, and you want to filter by a specific type and respect any inheritance hierarchy? Imagine that you have a sequence of exceptions. There are hundreds of exception types that form a complex inheritance hierarchy, as partially shown in Figure 11.4: Figure 11.4: A partial exception inheritance hierarchy Letâ€™s explore filtering by type: 1. In Program.Functions.cs, define a new method to list and then filter exception-derived objects using the OfType<T> extension method to remove exceptions that are not arithmetic excep- tions and write only the arithmetic exceptions to the console, as shown in the following code: static void FilteringByType() { SectionTitle("Filtering by type"); List<Exception> exceptions = new() 