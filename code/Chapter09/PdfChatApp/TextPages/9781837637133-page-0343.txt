Building and Securing Web Services Using Minimal APIs 310 For example, to update an entity in a database, you would need a database context to be retrieved from the registered dependency services, an identifier passed as a query string or route segment, and the new entity in the body of the request, as shown in the following code: app.MapPut("api/customers/{id}", async ( [FromServices] NorthwindContext db, [FromRoute] string id, // or [FromQuery] string id, [FromBody] Customer customer) => { Customer? existingCustomer = await db.Customers.FindAsync(id); ... }); Understanding return values A minimal API service can return data in some common formats, as shown in Table 8.1: Type Lambda () => "Hello World!" Plain text () => Results.Text("Hello World!") () => new { FirstName = "Bob", LastName = "Jones" } JSON document () => Results.Json(new { FirstName = "Bob", LastName = "Jones" }) () => Results.Ok(new { FirstName = "Bob", LastName = "Jones" }) IResult with status codes () => Results.NoContent() () => Results.Redirect("new/path") () => Results.NotFound() () => Results.BadRequest() () => Results.Problem() () => Results.StatusCode(405) () => Results.File("/path/filename.ext") File Table 8.1: Examples of minimal API return values Documenting a Minimal APIs service You can call additional methods as many times as you need to specify what return types and status codes can be expected from an endpoint, for example: • Produces<T>(StatusCodes.Status200OK): When successful, this route returns a response containing a type T and status code 200. Produces(StatusCodes.Status404NotFound): When no match for the route is found, this • route returns an empty response and status code 404. 