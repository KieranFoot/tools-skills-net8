Building and Securing Web Services Using Minimal APIs 308 const port = 3000 app.get('/', (req, res) => { res.send('Hello World!') }) app.listen(port, () => { console.log(`Example app listening on port ${port}`) }) With ASP.NET Core 5 or earlier, that would require more than fifty lines of code! The equivalent using ASP.NET Core 6 or later using ASP.NET Core Minimal APIs is now only five lines of code and six lines of configuration, as shown in the following two code blocks: int port = 3000; var app = WebApplication.Create(); app.MapGet("/", () => "Hello World!"); Console.WriteLine($"Example app listening on port {port}"); await app.RunAsync($"https://localhost:{port}/"); The platform is specified in the project file, and the implicit using statements SDK feature does some heavy lifting. It is enabled by default, as shown highlighted in the following markup: <Project Sdk="Microsoft.NET.Sdk.Web"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> </PropertyGroup> </Project> Good Practice: Another benefit of minimal APIs is that they do not use dynamically gener- ated code, unlike controller-based Web APIs. This allows them to use native AOT to produce smaller, faster services that are better for implementing and hosting microservices in containers. We will cover native AOT with minimal APIs later in this chapter. Whenever possible, implement your web services using minimal APIs instead of controllers. Understanding Minimal API route mappings The WebApplication instance has methods that you can call to map a route to a lambda expression or statement: • MapGet: Map a route to a GET request to retrieve an entity. MapPost: Map a route to a POST request to insert an entity. • MapPut: Map a route to a PUT request to update an entity. • 