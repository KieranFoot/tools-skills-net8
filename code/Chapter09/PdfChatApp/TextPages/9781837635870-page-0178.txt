Chapter 3 159 3. Run the code, enter Kermit, and view the result, as shown in the following output: Before parsing What is your age? Kermit After parsing When the code was executed, the error exception was caught, the default message and stack trace were not output, and the console app continued running. This is better than the default behavior, but it might be useful to see the type of error that occurred. Good Practice: You should never use an empty catch statement like this in production code because it “swallows” exceptions and hides potential problems. You should at least log the exception if you cannot or do not want to handle it properly, or rethrow it so that higher-level code can decide instead. You will learn about logging in Chapter 4, Writing, Debugging, and Testing Functions. Catching all exceptions To get information about any type of exception that might occur, you can declare a variable of type System.Exception to the catch block: 1. Add an exception variable declaration to the catch block and use it to write information about the exception to the console, as shown in the following code: catch (Exception ex) { WriteLine($"{ex.GetType()} says {ex.Message}"); } 2. Run the code, enter Kermit again, and view the result, as shown in the following output: Before parsing What is your age? Kermit System.FormatException says Input string was not in a correct format. After parsing Catching specific exceptions Now that we know which specific type of exception occurred, we can improve our code by catching just that type of exception and customizing the message that we display to the user. You can think of this as a form of testing: 1. Leave the existing catch block and, above it, add a new catch block for the format exception type, as shown in the following highlighted code: catch (FormatException) { 