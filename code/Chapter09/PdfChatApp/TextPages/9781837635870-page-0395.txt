Packaging and Distributing .NET Types 376 3. Navigate to the top of the code file, expand the collapsed region, and note that the assembly filename is System.Xml.XDocument.dll but the class is in the System.Xml.Linq namespace, as shown in the following code and Figure 7.1: #region Assembly System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a // C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\8.0.0\ref\ net8.0\System.Runtime.dll #endregion Figure 7.1: Assembly and namespace that contains the XDocument type 4. Close the XDocument [from metadata] tab. string or String and choose Go to Definition. 5. Right-click inside 6. Navigate to the top of the code file, expand the collapsed region, and note the assembly file- System.Runtime.dll but the class is in the System namespace. name is Your code editor is technically lying to you. If you remember when we wrote code in Chapter 2, Speaking C#, when we revealed the extent of the C# vocabulary, we discovered that the System.Runtime.dll assembly contains zero types. What the System.Runtime.dll assembly does contain are type-forwarders. These are special types that appear to exist in an assembly but are implemented elsewhere. In this case, they are implemented deep inside the .NET runtime using highly optimized code. You might want to use a type-forwarder if you refactor a type to move it from its original assembly to a different one. Without defining a type-forwarder, any projects that reference the original assembly will not find the type in it and a runtime exception will be thrown. You can read more about this contrived example at the following link: https://learn.microsoft.com/en-us/dotnet/standard/ . assembly/type-forwarding Sharing code with legacy platforms using .NET Standard Before .NET Standard, there were Portable Class Libraries (PCLs). With PCLs, you could create a li- brary of code and explicitly specify which platforms you want the library to support, such as Xamarin, Silverlight, and Windows 8. Your library could then use the intersection of APIs that are supported by the specified platforms. 