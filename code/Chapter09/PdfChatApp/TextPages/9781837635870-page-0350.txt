Chapter 6 331 Defining record struct types C# 10 introduced the ability to use the record keyword with struct types as well as class types. Letâ€™s see an example: 1. In the DisplacementVector type, add the record keyword, as highlighted in the following code: public record struct DisplacementVector(int X, int Y); 2. In Program.cs, note that == now does not have a compiler error. PeopleApp project and view the result, as shown in the following output: 3. Run the dv1.Equals(dv5): True) dv1 == dv5: True) A record struct has all the same benefits over a record class that a struct has over a class. One difference between record struct and record class declared using primary constructor syntax is that record struct is not immutable, unless you also apply the readonly keyword to the record struct declaration. A struct does not implement the == and != operators, but they are automatically implemented with a record struct. Good Practice: With this change, Microsoft recommends explicitly specifying class if you want to define a record class, even though the class keyword is optional, as shown in the following code: public record class ImmutableAnimal(string Name);. Releasing unmanaged resources In the previous chapter, we saw that constructors can be used to initialize fields and that a type may have multiple constructors. Imagine that a constructor allocates an unmanaged resource, that is, anything that is not controlled by .NET, such as a file or mutex under the control of the operating system. The unmanaged resource must be manually released because .NET cannot do it for us using its automatic garbage collection feature. Garbage collection is an advanced topic, so for this topic, I will show some code examples, but you do not need to write the code yourself. Each type can have a single finalizer that will be called by the .NET runtime when the resources need to be released. A finalizer has the same name as a constructor, that is, the name of the type, but it is prefixed with a tilde, ~, as shown in the following code: public class ObjectWithUnmanagedResources { public ObjectWithUnmanagedResources() // Constructor. { // Allocate any unmanaged resources. } 