Implementing Interfaces and Inheriting Classes 322 void Play(); void Pause(); } 2. In the PacktLibrary project, add a new class file named DvdPlayer.cs, and modify the state- ments in the file to implement the IPlayable interface, as shown in the following code: namespace Packt.Shared; public class DvdPlayer : IPlayable { public void Pause() { WriteLine("DVD player is pausing."); } public void Play() { WriteLine("DVD player is playing."); } } This is useful, but what if we decide to add a third method named Stop? Before C# 8, this would be impossible once at least one type is implemented in the original interface. One of the main traits of an interface is that it is a fixed contract. C# 8 allows you to add new members to an interface after release if those new members have a default implementation. C# purists do not like the idea, but for practical reasons, such as avoiding breaking changes or having to define a whole new interface, it is useful, and other languages such as Java and Swift enable similar techniques. Support for default interface implementations requires some fundamental changes to the underlying platform, so they are only supported with C# if the target framework is .NET 5 or later, .NET Core 3 or later, or .NET Standard 2.1. They are, therefore, not supported by .NET Framework. Letâ€™s add a default implementation to the interface: 1. Modify the IPlayable interface to add a Stop method with a default implementation, as high- lighted in the following code: namespace Packt.Shared; public interface IPlayable { 