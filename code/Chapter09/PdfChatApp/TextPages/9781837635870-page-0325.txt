Implementing Interfaces and Inheriting Classes 306 Good Practice: When a generic type has one definable type, it should be named T, for example, List<T>, where T is the type stored in the list. When a generic type has multiple definable types, it should use T as a name prefix and have a sensible name, for example, Dictionary<TKey, TValue>. Generics provides flexibility, is faster, and bugs are easier to avoid because type checks are made when adding items at compile time. We will not need to explicitly specify the System.Collections. namespace that contains Dictionary<TKey, TValue> because it is implicitly and globally Generic imported by default. Letâ€™s write some code to solve the problem by using generics: 1. In Program.cs, create an instance of the generic lookup collection Dictionary<TKey, TValue> and then add four items to it, as shown in the following code: // Define a generic lookup collection. Dictionary<int, string> lookupIntString = new(); lookupIntString.Add(key: 1, value: "Alpha"); lookupIntString.Add(key: 2, value: "Beta"); lookupIntString.Add(key: 3, value: "Gamma"); lookupIntString.Add(key: harry, value: "Delta"); 2. Note the compile error when using harry as a key, as shown in the following output: /Users/markjprice/Code/Chapter06/PeopleApp/Program.cs(98,32): error CS1503: Argument 1: cannot convert from 'Packt.Shared.Person' to 'int' [/ Users/markjprice/Code/Chapter06/PeopleApp/PeopleApp.csproj] 3. Replace harry with 4. key to 3, and use it to look up its value in the dictionary, as shown 4. Add statements to set the in the following code: key = 3; WriteLine(format: "Key {0} has value: {1}", arg0: key, arg1: lookupIntString[key]); 5. Run the PeopleApp project and note that it works, as shown in the following output: Key 3 has value: Gamma You have now seen the difference between non-generic and generic types that need the flexibility to store any type. You know to always use generic collection types if possible. Unless you are unlucky enough to be forced to use a legacy non-generic library, you never need to write code that uses non-ge- neric types that can store any type again. 