Writing, Debugging, and Testing Functions 214 partial class Program { static void LogSourceDetails( bool condition, [CallerMemberName] string member = "", [CallerFilePath] string filepath = "", [CallerLineNumber] int line = 0, [CallerArgumentExpression(nameof(condition))] string expression = "") { Trace.WriteLine(string.Format( "[{0}]\n {1} on line {2}. Expression: {3}", filepath, member, line, expression)); } } 3. In Program.cs, at the bottom of the file, before the calls to close Debug and Trace, add state- ments to declare and set a variable that will be used in an expression that is passed to the function named LogSourceDetails, as shown highlighted in the following code: int unitsInStock = 12; LogSourceDetails(unitsInStock > 10); // Close the text file (also flushes) and release resources. Debug.Close(); Trace.Close(); We are just making up an expression in this scenario. In a real project, this might be an expression that is dynamically generated by the user making user interface selections to query a database or so on. 4. Run the console app without debugging, press Enter and close the console app, and then open log.txt file and note the result, as shown in the following output: the [C:\cs12dotnet8\Chapter04\Instrumenting\Program.cs] <Main>$ on line 44. Expression: unitsInStock > 10 Unit testing Fixing bugs in code is expensive. The earlier that a bug is discovered in the development process, the less expensive it will be to fix. 