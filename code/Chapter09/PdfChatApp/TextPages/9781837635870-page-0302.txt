Chapter 5 283 You could also use the relational pattern in combination with the property pattern to avoid the nested switch expression, as shown in the following code: FirstClassPassenger { AirMiles: > 35000 } => 1500M, FirstClassPassenger { AirMiles: > 15000 } => 1750M, FirstClassPassenger => 2000M, More Information: There are many more ways to use pattern matching in your projects. I recommend that you review the official documentation at the following link: https:// learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern- matching. Working with record types Before we dive into the new record language feature, let us see some other related new features of C# 9 and later. Init-only properties You have used object initialization syntax to instantiate objects and set initial properties throughout this chapter. Those properties can also be changed after instantiation. Sometimes, you want to treat properties like readonly fields so that they can be set during instantia- tion but not after. In other words, they are immutable. The init keyword enables this. It can be used in place of the set keyword in a property definition. Since this is a language feature not supported by .NET Standard 2.0, we cannot use it in the PacktLibraryNetStandard2 project. We must use it in the modern project: 1. In the PacktLibraryModern project, add a new file named Records.cs. In Records.cs, define a person class with two immutable properties, as shown in the following 2. code: namespace Packt.Shared; public class ImmutablePerson { public string? FirstName { get; init; } public string? LastName { get; init; } } 3. In Program.cs, add statements to instantiate a new immutable person, and then try to change one of its properties, as shown in the following code: ImmutablePerson jeff = new() { 