Chapter 3 103 Some data in the table might look like Table 3.5: Id Name Discriminator Subject HireDate 1 Roman Roy Student History NULL 2 Kendall Roy Employee NULL 02/04/2014 3 Siobhan Roy Employee NULL 12/09/2020 Table 3.5: Sample data in the People table TPH requires the Discriminator column to store the class name of the type for each row. TPH requires the columns for properties of derived types to be nullable, like Subject and HireDate. This will cause an issue if those properties are required (non-null) at the class level. EF Core does not handle this by default. The main benefits of the TPH mapping strategy are simplicity and performance, which is why it is used by default. Good Practice: If the discriminator column has many different values, then you can im- prove performance even more by defining an index on the discriminator. But if there are only a few different values, an index may make overall performance worse because it affects updating time. In this case, there are only two potential values, Student and Employee, so in a table with 100,000 rows, an index would make little difference. Table-per-type (TPT) mapping strategy For the Person-Student-Employee hierarchy, TPT will use a table for every type, as shown in the following code: CREATE TABLE [People] ( [Id] int NOT NULL IDENTITY, [Name] nvarchar(max) NOT NULL, CONSTRAINT [PK_People] PRIMARY KEY ([Id]) ); CREATE TABLE [Students] ( [Id] int NOT NULL, [Subject] nvarchar(max) NULL, CONSTRAINT [PK_Students] PRIMARY KEY ([Id]) CONSTRAINT [FK_Students_People] FOREIGN KEY ([Id]) REFERENCES [People] ([Id]) ); CREATE TABLE [Employees] ( [Id] int NOT NULL, [HireDate] nvarchar(max) NULL, 