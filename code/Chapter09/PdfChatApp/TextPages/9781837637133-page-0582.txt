Chapter 12 549 37: Gravad lax 40: Boston Crab Meat 41: Jack's New England Clam Chowder 45: Rogede sild 46: Spegesild 58: Escargots de Bourgogne 73: Röd Kaviar Implementing GraphQL mutations Most services need to modify data as well as query it. GraphQL calls these mutations. A mutation has three related components: • The mutation itself, which defines the change that will be made to the graph. It should be named using a verb, a noun, and use camel casing, for example, addProduct. • The input is the input for a mutation, and it should have the same name as the mutation with a suffix of Input, for example, AddProductInput. Although there is only one input, it is an object graph, so it can be as complex as you need. • The payload is the returned document for a mutation, and it should have the same name as the mutation with a suffix of Payload, for example, AddProductPayload. Although there is only one payload, it is an object graph, so it can be as complex as you need. Adding mutations to the GraphQL service Let’s define mutations for adding, and later, we will define some to update and delete products: 1. In the Northwind.GraphQL.Service project/folder, add a class file named Mutation.cs. In the class file, define a record and two classes to represent the three types needed to perform 2. an addProduct mutation, as shown in the following code: using Northwind.EntityModels; // To use Product. namespace Northwind.GraphQL.Service; // Inputs are readonly so we will use a record. public record AddProductInput( string ProductName, int? SupplierId, int? CategoryId, string QuantityPerUnit, decimal? UnitPrice, short? UnitsInStock, short? UnitsOnOrder, short? ReorderLevel, 