Chapter 2 79 "City":"Frankfurt","Country":"Germany"}, {"SupplierId":13, "CompanyName":"Nord-Ost-Fisch Handelsgesellschaft mbH", "City":"Cuxhaven","Country":"Germany"}] BytesReceived: 1,430 BytesSent: 240 SelectRows: 3 ExecutionTime: 5 6. At the bottom of Program.cs, add statements to run the GetExpensiveProducts stored pro- cedure, passing a price parameter value of 100, enumerate the collection outputting basic information about each one, and then serialize the collection as JSON to the console, as shown in the following code: IEnumerable<Product> productsFromDapper = connection.Query<Product>(sql: "GetExpensiveProducts", param: new { price = 100M, count = 0 }, commandType: CommandType.StoredProcedure); foreach (Product p in productsFromDapper) { WriteLine("{0}: {1}, {2}", p.ProductId, p.ProductName, p.UnitPrice); } WriteLineInColor(JsonSerializer.Serialize(productsFromDapper), ConsoleColor.Green); Warning! With Dapper, you must pass a param object with all parameters, even if they are only used as output parameters. For example, we must define count, or an exception will be thrown. You must also remember to explicitly set the command type to stored procedure! Run the console app, and in the section where we used Dapper to run the stored procedure to get the products that cost more than 100, note the same connection was used so its events were raised while the Dapper query was executed, the enumerated collection output, and then JSON generated from the list of products, as shown in the following output: Info: Getting expensive products: 100.00. 29: Thüringer Rostbratwurst, 123.7900 38: Côte de Blaye, 263.5000 