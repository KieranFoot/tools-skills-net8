Implementing Interfaces and Inheriting Classes 308 I can call this method on an instance of Person named p1 like this: Person p1 = new(); int answer = p1.MethodIWantToCall("Frog"); Alternatively, I can define a delegate with a matching signature to call the method indirectly. Note that the names of the parameters do not have to match. Only the types of parameters and return values must match, as shown in the following code: delegate int DelegateWithMatchingSignature(string s); Good Practice: A delegate is a reference type like a class, so if you define one in Program. cs then it must be at the bottom of the file. It would be best to define it in its own class file, for example, Program.Delegates.cs. If you defined a delegate in the middle of Program. cs, then you would see the following compiler error: CS8803: Top-level statements must precede namespace and type declarations. Now, I can create an instance of the delegate, point it at the method, and finally, call the delegate (which calls the method), as shown in the following code: // Create a delegate instance that points to the method. DelegateWithMatchingSignature d = new(p1.MethodIWantToCall); // Call the delegate, which then calls the method. int answer2 = d("Frog"); Examples of delegate use You are probably thinking, “What’s the point of that?” It provides flexibility. For example, we could use delegates to create a queue of methods that need to be called in order. Queuing actions that need to be performed is common in services to provide improved scalability. Another example is to allow multiple actions to execute in parallel. Delegates have built-in support for asynchronous operations that run on a different thread, which can provide improved responsiveness. The most important example is that delegates allow us to implement events to send messages between different objects that do not need to know about each other. Events are an example of loose coupling between components because they do not need to know about each other; they just need to know the event signature. Status: It’s complicated Delegates and events are two of the most confusing features of C# and can take a few attempts to un- derstand, so don’t worry if you feel lost as we walk through how they work! Move on to other topics and come back again another day when your brain has had the opportunity to process the concepts while you sleep. 