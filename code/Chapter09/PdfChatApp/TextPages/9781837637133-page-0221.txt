Multitasking and Concurrency 188 Good Practice: Note that since checking the conch is voluntary, if you only use the lock statement in one of the two methods, the shared resource will continue to be accessed by both methods. Make sure that all methods that access a shared resource respect the conch by calling lock on it before trying to use any shared resources. 3. Run the code and view the result, as shown in the following output: Please wait for the tasks to complete. .......... Results: BBBBBAAAAA. 10,345 elapsed milliseconds. Although the time elapsed was longer, only one method at a time could access the shared resource. Either MethodA or MethodB can start first. Once a method has finished its work on the shared resource, then the conch gets released, and the other method has the chance to do its work. Understanding the lock statement You might wonder what the lock statement does when it “locks” an object variable (hint: it does not lock the object!), as shown in the following code: lock (SharedObjects.Conch) { // Work with a shared resource. } The C# compiler changes the lock statement into a try-finally statement that uses the Monitor class to enter and exit the conch object (I like to think of it as take and release the conch object), as shown in the following code: try { Monitor.Enter(SharedObjects.Conch); // Work with a shared resource. } finally { Monitor.Exit(SharedObjects.Conch); } When a thread calls Monitor.Enter on a reference type, it checks to see if some other thread has already taken the conch. If it has, the thread waits. If it has not, the thread takes the conch and gets Monitor.Exit, on with its work on the shared resource. Once the thread has finished its work, it calls releasing the conch. 