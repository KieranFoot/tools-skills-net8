Chapter 3 115 WriteLine(db.Database.GenerateCreateScript()); if ((db.Employees is not null) && (db.Students is not null)) { db.Students.Add(new Student { Name = "Connor Roy", Subject = "Politics" }); db.Employees.Add(new Employee { Name = "Kerry Castellabate", HireDate = DateTime.UtcNow }); int result = db.SaveChanges(); WriteLine($"{result} people added."); } 23. Start the console app, and note the results, including the two new people added using the database context with IDs that start at 4, as shown in the following partial output: 2 people added. Roman Roy studies History Connor Roy studies Politics Kendall Roy was hired on 02/04/2014 00:00:00 Siobhan Roy was hired on 12/09/2020 00:00:00 Kerry Castellabate was hired on 19/05/2023 10:13:53 Kendall Roy has ID of 2 Siobhan Roy has ID of 3 Kerry Castellabate has ID of 4 Roman Roy has ID of 1 Connor Roy has ID of 5 You’ve now seen how an object-relational mapper like EF Core can define an object inheritance hier- archy and map it in three different ways to an underlying database structure with one or more related tables. You’ve also seen how Code First works especially well with this since it is so easy to delete and recreate the database each time the project starts. Building a reusable entity data model Practical applications usually need to work with data in a relational database or another data store. Earlier in this chapter, we defined EF Core models in the same console app project that we used them in. Now, we will define an entity data model for the Northwind database as a pair of reusable class libraries. One part of the pair will define the entities, like Product and Customer. The second part of the pair will define the tables in the database and the default configuration for how to connect to the database, and use the Fluent API to configure additional options for the model. This pair of class libraries will be used in many of the apps and services that you create in subsequent chapters. 