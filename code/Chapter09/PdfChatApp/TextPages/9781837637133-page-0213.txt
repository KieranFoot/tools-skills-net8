Multitasking and Concurrency 180 However, the actual CPU used has a big effect on the results. It is the CPU that allocates time slices to each process to allow them to execute their threads. You have no control over when the methods run. Continuing with another task If all three tasks can be performed at the same time, then waiting for all tasks to finish will be all we need to do. However, often, a task is dependent on the output from another task. To handle this sce- nario, we need to define continuation tasks. We will create some methods to simulate a call to a web service that returns a monetary amount, which then needs to be used to retrieve how many products cost more than that amount in a database. The result returned from the first method needs to be fed into the input of the second method. This time, instead of waiting for fixed amounts of time, we will use the Random class to wait for a random interval between 2 and 4 seconds for each method call to simulate the work: 1. In Program.Methods.cs, add two methods that simulate calling a web service and a data- base-stored procedure, as shown in the following code: private static decimal CallWebService() { TaskTitle("Starting call to web service..."); OutputThreadInfo(); Thread.Sleep(Random.Shared.Next(2000, 4000)); TaskTitle("Finished call to web service."); return 89.99M; } private static string CallStoredProcedure(decimal amount) { TaskTitle("Starting call to stored procedure..."); OutputThreadInfo(); Thread.Sleep((Random.Shared.Next(2000, 4000)); TaskTitle("Finished call to stored procedure."); return $"12 products cost more than {amount:C}."; } 2. In Program.cs, comment out the statements for the previous three tasks, and then add state- ments to start a task to call the web service and then pass its return value to a task that starts the database-stored procedure, as shown highlighted in the following code: SectionTitle("Passing the result of one task as an input into another."); Task<string> taskServiceThenSProc = Task.Factory .StartNew(CallWebService) // returns Task<decimal> .ContinueWith(previousTask => // returns Task<string> 