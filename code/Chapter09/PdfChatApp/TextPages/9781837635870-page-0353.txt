Implementing Interfaces and Inheriting Classes 334 // Code that uses thing. } finally { if (thing != null) thing.Dispose(); } When someone uses a type that implements IAsyncDisposable, they can ensure that the public Dispose method is called with the await using statement, as shown in the following code: await using (ObjectWithUnmanagedResources thing = new()) { // Code that uses async thing. } You will see practical examples of releasing unmanaged resources with IDisposable, using statements, and try...finally blocks in Chapter 9, Working with Files, Streams, and Serialization. Working with null values You have seen how reference types are different from value types in how they are stored in memory, as well as how to store primitive values like numbers in struct variables. But what if a variable does null value, which can be used not yet have a value? How can we indicate that? C# has the concept of a to indicate that a variable has not been set. Making a value type nullable By default, value types like int and DateTime must always have a value, hence their name. Sometimes, for example, when reading values stored in a database that allows empty, missing, or null values, it is convenient to allow a value type to be null. We call this a nullable value type. You can enable this by adding a question mark as a suffix to the type when declaring a variable. Letâ€™s see an example. We will create a new project because some of the null handling options are set at the project level: 1. Use your preferred coding tool to add a new Console App / console project named NullHandling to the Chapter06 solution. In NullHandling.csproj, add an <ItemGroup> to globally and statically import the System. 2. Console class. Program.cs, delete the existing statements, and then add statements to declare and assign 3. In values, including null, to int variables, one suffixed with ? and one not, as shown in the following code: int thisCannotBeNull = 4; thisCannotBeNull = null; // CS0037 compiler error! WriteLine(thisCannotBeNull); 