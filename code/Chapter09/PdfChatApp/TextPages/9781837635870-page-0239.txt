Writing, Debugging, and Testing Functions 220 4. Hover your mouse pointer over CalculatorUnitTests and then click the Run Tests button (black triangle icon) defined in that class. Click the TEST RESULTS tab and note that the results indicate that two tests ran, one test passed, 5. and one test failed, as shown in Figure 4.23: Figure 4.23: The unit test results in Visual Studio Code’s TERMINAL Fixing the bug Now you can fix the bug: 1. Fix the bug in the Add method. 2. Run the unit tests again to see that the bug has now been fixed and both tests have passed. Now that we’ve written, debugged, logged, and unit-tested functions, let’s finish this chapter by looking at how to throw and catch exceptions in functions. Throwing and catching exceptions in functions In Chapter 3, Controlling Flow, Converting Types, and Handling Exceptions, you were introduced to excep- tions and how to use a try-catch statement to handle them. But you should only catch and handle an exception if you have enough information to mitigate the issue. If you do not, then you should allow the exception to pass up through the call stack to a higher level. Understanding usage errors and execution errors Usage errors are when a programmer misuses a function, typically by passing invalid values as param- eters. They could be avoided by that programmer changing their code to pass valid values. When some programmers first learn C# and .NET, they sometimes think exceptions can always be avoided because they assume all errors are usage errors. Usage errors should all be fixed before production runtime. 