Chapter 7 267 WriteLine($"Long time pattern: {dtfi.LongTimePattern}"); WriteLine($"Short time pattern: {dtfi.ShortTimePattern}"); Write("Day names:"); for (int i = 0; i < dtfi.DayNames.Length - 1; i++) { Write($" {dtfi.GetDayName((DayOfWeek)i)}"); } WriteLine(); Write("Month names:"); for (int i = 1; i < dtfi.MonthNames.Length; i++) { Write($" {dtfi.GetMonthName(i)}"); } WriteLine(); 2. Run the code, and note the results, as shown in the following output: *** Working with date/time formats Date separator: / Time separator: : Long date pattern: dddd, MMMM d, yyyy Short date pattern: M/d/yyyy Long time pattern: h:mm:ss tt Short time pattern: h:mm tt Day names: Sunday Monday Tuesday Wednesday Thursday Friday Month names: January February March April May June July August September October November December 3. Change the culture to something else, run the code, and note the results. Unit testing with a time provider Writing unit tests for components that need the current time is tricky because the time is constantly changing! Imagine you want visitors to your e-commerce website to get a 20% discount if they make an order at the weekend. During workdays, they pay full price. How can we test this functionality? To control the time used in unit tests, .NET 8 introduces the TimeProvider class. Letâ€™s start defining a function to perform this calculation: 1. In the Chapter07 solution, add a new Class Library/classlib project named TimeFunctionsLib. 