Implementing Interfaces and Inheriting Classes 332 ~ObjectWithUnmanagedResources() // Finalizer aka destructor. { // Deallocate any unmanaged resources. } } Do not confuse a finalizer (also known as a destructor) with a Deconstruct method. A destructor releases resources; in other words, it destroys an object in memory. A Deconstruct method returns an object split up into its constituent parts and uses the C# deconstruction syntax, for example, when working with tuples. See Chapter 5, Building Your Own Types with Object-Oriented Programming, for details of Deconstruct methods. The preceding code example is the minimum you should do when working with unmanaged resources. However, the problem with only providing a finalizer is that the .NET garbage collector requires two garbage collections to completely release the allocated resources for this type. Though optional, it is recommended to also provide a method to allow a developer who uses your type to explicitly release resources. This would allow the garbage collector to release managed parts of an unmanaged resource, such as a file, immediately and deterministically. This would mean it releases the managed memory part of the object in a single garbage collection instead of two rounds of garbage collection. There is a standard mechanism to do this by implementing the IDisposable interface, as shown in the following example: public class ObjectWithUnmanagedResources : IDisposable { public ObjectWithUnmanagedResources() { // Allocate unmanaged resource. } ~ObjectWithUnmanagedResources() // Finalizer. { Dispose(false); } bool disposed = false; // Indicates if resources have been released. public void Dispose() { Dispose(true); // Tell garbage collector it does not need to call the finalizer. GC.SuppressFinalize(this); 