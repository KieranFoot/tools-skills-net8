Chapter 5 189 If another thread was waiting, it could now take the conch and do its work. This requires all threads to respect the conch by calling Monitor.Enter and Monitor.Exit appropriately. Good Practice: You cannot use value types (struct types) as a conch. Monitor.Enter requires a reference type because it locks the memory address. Any internal data struc- tures for that object are not locked. Avoiding deadlocks Knowing how the lock statement is translated by the compiler to method calls on the Monitor class lock statement can cause a deadlock. is also important because using the Deadlocks can occur when there are two or more shared resources (each with a conch to monitor which thread is currently doing work on each shared resource), and the following sequence of events happens: • Thread X “locks” conch A and starts working on shared resource A. • Thread Y “locks” conch B and starts working on shared resource B. • While still working on resource A, thread X needs to also work with resource B, and so it at- tempts to “lock” conch B but is blocked because thread Y already has conch B. • While still working on resource B, thread Y needs to also work with resource A, and so it at- tempts to “lock” conch A but is blocked because thread X already has conch A. One way to prevent deadlocks is to specify a timeout when attempting to get a lock. To do this, you Monitor class instead of using the lock statement. Let’s see how: must manually use the 1. In Program.Methods.cs, modify your code to replace the lock statements with code that tries to enter the conch with a timeout, outputs an error, and then exits the monitor, allowing other threads to enter the monitor, as shown highlighted in the following code for MethodB: try { if (Monitor.TryEnter(SharedObjects.Conch, TimeSpan.FromSeconds(15))) { for (int i = 0; i < 5; i++) { Thread.Sleep(Random.Shared.Next(2000)); SharedObjects.Message += "B"; Write("."); } } else { WriteLine("Method B timed out when entering a monitor on conch."); } 