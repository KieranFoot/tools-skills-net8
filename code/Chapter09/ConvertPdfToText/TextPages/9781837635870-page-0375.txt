Implementing Interfaces and Inheriting Classes 356 WriteLine($"Welcome to {when:yyyy}!"); } } 4. In Program.cs, add statements to test what happens when employee John Jones tries to time-travel too far back, as shown in the following code: try { john.TimeTravel(when: new(1999, 12, 31)); john.TimeTravel(when: new(1950, 12, 25)); } catch (PersonException ex) { WriteLine(ex.Message); } 5. Run the PeopleApp project and view the result, as shown in the following output: Welcome to 1999! If you travel back in time to a date earlier than your own birth, then the universe will explode! Good Practice: When defining your own exceptions, give them the same three construc- tors that explicitly call the built-in ones in System.Exception. Other exceptions that you might inherit from may have more. Extending types when you can’t inherit Earlier, we saw how the sealed modifier can be used to prevent inheritance. Microsoft has applied the sealed keyword to the System.String class so that no one can inherit and potentially break the behavior of strings. Can we still add new methods to strings? Yes, if we use a language feature named extension methods, which was introduced with C# 3.0. To properly understand extension methods, we need to review static methods first. Using static methods to reuse functionality Since the first version of C#, we’ve been able to create static methods to reuse functionality, such as the ability to validate that a string contains an email address. The implementation will use a regular expression that you will learn more about in Chapter 8, Working with Common .NET Types. 