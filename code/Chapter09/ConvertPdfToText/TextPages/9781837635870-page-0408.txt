Chapter 7 389 If you cannot assume that .NET is already installed on a computer, then although Linux also only generates the two files, expect the following additional files for Windows: coreclr.dll, clrjit.dll, clrcompression.dll, and mscordaccore.dll. Letâ€™s see an example for Windows: 1. At the command prompt or terminal, in the DotNetEverywhere folder, enter the command to build the self-contained release version of the console app for Windows 10, as shown in the following command: dotnet publish -c Release -r win10-x64 --self-contained /p:PublishSingleFile=true 2. Navigate to the DotNetEverywhere\bin\Release\net8.0\win10-x64\publish folder and select the DotNetEverywhere executable file. Note that the executable is now 62.6 MB, and there is also a .pdb file that is 11 KB. The sizes of these files on your system will vary. Reducing the size of apps using app trimming One of the problems with deploying a .NET app as a self-contained app is that the .NET libraries take up a lot of space. One of the biggest needs is to reduce the size of Blazor WebAssembly components because all the .NET libraries need to be downloaded to the browser. Luckily, you can reduce this size by not packaging unused assemblies with your deployments. Intro- duced with .NET Core 3, the app trimming system can identify the assemblies needed by your code and remove those that are not needed. This was known as copyused trim mode. With .NET 5, the trimming went further by removing individual types, and even members, like meth- ods from within an assembly if they are not used. For example, with a Hello World console app, the System.Console.dll assembly is trimmed from 61.5 KB to 31.5 KB. This was known as link trim mode, but it was not enabled by default. With .NET 6, Microsoft added annotations to their libraries to indicate how they can be safely trimmed, so the trimming of types and members was made the default. With .NET 7, Microsoft renamed link to full and copyused to partial. The catch is how well the trimming identifies unused assemblies, types, and members. If your code is dynamic, perhaps using reflection, then it might not work correctly, so Microsoft also allows manual control. There are two ways to enable type-level and member-level, aka full, trimming. Since this level of trimming is the default with .NET 6 or later, all we need to do is enable trimming without setting a trim level or mode. The first way is to add an element in the project file, as shown in the following markup: <PublishTrimmed>true</PublishTrimmed> <!--Enable trimming.--> 