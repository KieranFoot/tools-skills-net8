Chapter 6 309 Defining and handling delegates Microsoft has two predefined delegates for use as events. They both have two parameters: • object? sender: This parameter is a reference to the object raising the event or sending the message. The ? indicates that this reference could be null. EventArgs e or TEventArgs e: This parameter contains additional relevant information • about the event. For example, in a GUI app, you might define MouseMoveEventArgs, which has properties for the X and Y coordinates for the mouse pointer. A bank account might have a WithdrawEventArgs with a property for the Amount to withdraw. Their signatures are simple, yet flexible, as shown in the following code: // For methods that do not need additional argument values passed in. public delegate void EventHandler(object? sender, EventArgs e); // For methods that need additional argument values passed in as // defined by the generic type TEventArgs. public delegate void EventHandler<TEventArgs>(object? sender, TEventArgs e); Good Practice: When you want to define an event in your own type, you should use one of these two predefined delegates. Let’s explore delegates and events: 1. Add statements to the Person class and note the following points, as shown in the following code: • It defines an EventHandler delegate field named Shout. int field to store AngerLevel. • It defines an Poke. • It defines a method named Each time a person is poked, their AngerLevel increments. Once their AngerLevel • reaches three, they raise the Shout event, but only if there is at least one event delegate pointing at a method defined somewhere else in the code; that is, it is not null: #region Events // Delegate field to define the event. public EventHandler? Shout; // null initially. // Data field related to the event. public int AngerLevel; // Method to trigger the event in certain conditions. 