Controlling Flow, Converting Types, and Handling Exceptions 148 9. Modify the value of e to 5 billion, as shown in the following code: e = 5_000_000_000; 10. Run the code to view the results, as shown in the following output: e is 5,000,000,000, f is 705,032,704 Five billion cannot fit into a 32-bit integer, so it overflows (wraps around) to about 705 million. It is all to do with the binary representation of integer numbers. You will see more examples of integer overflow and how to handle it later in this chapter. How negative numbers are represented in binary You might have wondered why f had the value -1 in the previous code. Negative aka signed numbers 0 (zero), then it is a positive number. If the bit is 1 use the first bit to represent negativity. If the bit is (one), then it is a negative number. Letâ€™s write some code to illustrate this: 1. Enter statements to output the maximum value for an int in decimal and binary number for- mats, then output the values 8 to -8, decrementing by one, and finally output the minimum int, as shown in the following code: value for an WriteLine("{0,12} {1,34}", "Decimal", "Binary"); WriteLine("{0,12} {0,34:B32}", int.MaxValue); for (int i = 8; i >= -8; i--) { WriteLine("{0,12} {0,34:B32}", i); } WriteLine("{0,12} {0,34:B32}", int.MinValue); Note ,12 and ,34 mean right-align within those column widths. :B32 means format as binary padded with leading zeros to a width of 32. 2. Run the code to view the results, as shown in the following output: Decimal Binary 2147483647 01111111111111111111111111111111 8 00000000000000000000000000001000 7 00000000000000000000000000000111 6 00000000000000000000000000000110 5 00000000000000000000000000000101 