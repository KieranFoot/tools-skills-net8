Implementing Interfaces and Inheriting Classes 362 With C# 8, interfaces can now include default implementations, making them more like abstract classes, and the term inherit for an interface that has default implementations does make sense. But I feel uncomfortable with this capability, as do many other .NET developers, because it messes up what used to be a clean language design. Default interfaces also require changes to the underlying .NET runtime, so they cannot be used with legacy platforms like .NET Standard 2.0 class libraries and .NET Framework. Classes can also have abstract members, for example, methods or properties without any implemen- tation, just like an interface could have. When a subclass inherits from this class, it MUST provide an implementation of those abstract members, and the base class must be decorated with the abstract new because it is missing some functionality. keyword to prevent it from being instantiated using Reviewing illustrative code Let’s review some example code that illustrates some of the important differences between types. Note the following: • To simplify the code, I have left out access modifiers like private and public. • Instead of normal brace formatting, to save vertical space I have put all the method imple- mentation in one statement, for example: void M1() { /* implementation */ } • Using “I” as a prefix for interfaces is a convention, not a requirement. It is useful to highlight interfaces using this prefix, since only interfaces support multiple inheritance. Here’s the code: // These are both "classic" interfaces in that they are pure contracts. // They have no functionality, just the signatures of members that // must be implemented. interface IAlpha { // A method that must be implemented in any type that implements // this interface. void M1(); } interface IBeta { void M2(); // Another method. } // A type (a struct in this case) implementing an interface. 