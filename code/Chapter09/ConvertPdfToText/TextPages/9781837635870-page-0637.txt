Querying and Manipulating Data Using LINQ 618 So, the best answer to Amichai’s teaser is “Something else.” Good Practice: Be careful when calling LINQ extension methods like Count that need to enumerate over the sequence to calculate their return value. Even if you are not working with a sequence of executable objects like tasks, re-enumerating the sequence is likely to be inefficient. Paging with LINQ Let’s see how we could implement paging using the Skip and Take extension methods: 1. In Program.Functions.cs, add a method to output to the console a table of products passed as an array, as shown in the following code: private static void OutputTableOfProducts(Product[] products, int currentPage, int totalPages) { string line = new('-', count: 73); string lineHalf = new('-', count: 30); WriteLine(line); WriteLine("{0,4} {1,-40} {2,12} {3,-15}", "ID", "Product Name", "Unit Price", "Discontinued"); WriteLine(line); foreach (Product p in products) { WriteLine("{0,4} {1,-40} {2,12:C} {3,-15}", p.ProductId, p.ProductName, p.UnitPrice, p.Discontinued); } WriteLine("{0} Page {1} of {2} {3}", lineHalf, currentPage + 1, totalPages + 1, lineHalf); } As usual in computing, our code will start counting from 0, so we need to add 1 to both the currentPage count and totalPages count before showing these values in a user interface. 2. In Program.Functions.cs, add a method to create a LINQ query that creates a page of products, outputs the SQL generated from it, and then passes the results as an array of products to the method that outputs a table of products, as shown in the following code: private static void OutputPageOfProducts(IQueryable<Product> products, int pageSize, int currentPage, int totalPages) 