Chapter 6 333 } protected virtual void Dispose(bool disposing) { if (disposed) return; // Deallocate the *unmanaged* resource. // ... if (disposing) { // Deallocate any other *managed* resources. // ... } disposed = true; } } There are two Dispose methods, one public and one protected: • The public void Dispose method will be called by a developer using your type. When called, both unmanaged and managed resources need to be deallocated. The protected virtual void Dispose method with a bool parameter is used internally to imple- • ment the deallocation of resources. It needs to check the disposing parameter and disposed field because if the finalizer thread has already run and called the ~ObjectWithUnmanagedResources method, then only managed resources need to be deallocated by the garbage collector. The call to GC.SuppressFinalize(this) is what notifies the garbage collector that it no longer needs to run the finalizer, removing the need for a second garbage collection. Ensuring that Dispose is called When someone uses a type that implements IDisposable, they can ensure that the public Dispose method is called with the using statement, as shown in the following code: using (ObjectWithUnmanagedResources thing = new()) { // Code that uses thing. } The compiler converts your code into something like the following, which guarantees that even if an exception occurs, the Dispose method will still be called: ObjectWithUnmanagedResources thing = new(); try { 