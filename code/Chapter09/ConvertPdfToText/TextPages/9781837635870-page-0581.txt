Working with Data Using Entity Framework Core 562 WHERE NOT ("p"."Discontinued") AND "p"."CategoryId" = @__p_0 Beverages has 11 products. Explicitly load products for Condiments? (Y/N): n Condiments has 0 products. Explicitly load products for Confections? (Y/N): n Confections has 0 products. Explicitly load products for Dairy Products? (Y/N): n Dairy Products has 0 products. Explicitly load products for Grains/Cereals? (Y/N): n Grains/Cereals has 0 products. Explicitly load products for Meat/Poultry? (Y/N): n Meat/Poultry has 0 products. Explicitly load products for Produce? (Y/N): n Produce has 0 products. Explicitly load products for Seafood? (Y/N): y dbug: 05/03/2023 13:49:16.682 RelationalEventId.CommandExecuting[20100] (Microsoft.EntityFrameworkCore.Database.Command) Executing DbCommand [Parameters=[@__p_0='8'], CommandType='Text', CommandTimeout='30'] SELECT "p"."ProductId", "p"."CategoryId", "p"."UnitPrice", "p"."Discontinued", "p"."ProductName", "p"."UnitsInStock" FROM "Products" AS "p" WHERE NOT ("p"."Discontinued") AND "p"."CategoryId" = @__p_0 Seafood has 12 products. Good Practice: Carefully consider which loading pattern is best for your code. Lazy loading could literally make you a lazy database developer! Read more about loading patterns at the following link: https://learn.microsoft.com/en-us/ef/core/querying/related- data. Controlling the tracking of entities We need to start with the definition of entity identity resolution. EF Core resolves each entity instance by reading its unique primary key value. This ensures no ambiguities about the identities of entities or relationships between them. By default, EF Core assumes that you want to track entities in local memory so that if you make changes, like adding a new entity, modifying an existing entity, or removing an existing entity, then you can call SaveChanges and all those changes will be made in the underlying data store. 