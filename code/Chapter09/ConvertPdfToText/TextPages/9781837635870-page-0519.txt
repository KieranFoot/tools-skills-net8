Working with Files, Streams, and Serialization 500 using (StreamWriter jsonStream = File.CreateText(jsonPath)) { Newtonsoft.Json.JsonSerializer jss = new(); // Serialize the object graph into a string. jss.Serialize(jsonStream, people); } // Closes the file stream and release resources. OutputFileInfo(jsonPath); 4. Run the code, and note that JSON requires fewer than half the number of bytes compared to XML with elements. It’s even smaller than the XML file, which uses attributes (366 compared to 488), as shown in the following output: **** File Info **** File: people.json Path: C:\cs12dotnet8\Chapter09\WorkingWithSerialization\bin\Debug\net8.0 Size: 366 bytes. /------------------ [{"FirstName":"Alice","LastName":"Smith","DateOfBirth":"1974-03- 14T00:00:00","Children":null},{"FirstName":"Bob","LastName":"Jones","Date OfBirth":"1969-11-23T00:00:00","Children":null},{"FirstName":"Charlie","L astName":"Cox","DateOfBirth":"1984-05-04T00:00:00","Children":[{"FirstNam e":"Sally","LastName":"Cox","DateOfBirth":"2012-07-12T00:00:00","Children ":null}]}] ------------------/ High-performance JSON processing .NET Core 3 introduced a new namespace to work with JSON, System.Text.Json, which is optimized for performance by leveraging APIs like Span<T>. Also, older libraries like Json.NET are implemented by reading UTF-16. It would be more performant to read and write JSON documents using UTF-8 because most network protocols, including HTTP, use UTF-8, and you can avoid transcoding UTF-8 to and from Json.NET’s Unicode string values. With the new API, Microsoft achieved between 1.3x and 5x improvement, depending on the scenario. The original author of Json.NET, James Newton-King, joined Microsoft and is working with them to develop their new JSON types. As he says in a comment discussing the new JSON APIs, “Json.NET isn’t going away,” as shown in Figure 9.6: 