Implementing Interfaces and Inheriting Classes 310 public void Poke() { AngerLevel++; if (AngerLevel < 3) return; // If something is listening to the event... if (Shout is not null) { // ...then call the delegate to "raise" the event. Shout(this, EventArgs.Empty); } } #endregion Checking whether an object is not null before calling one of its methods is very common. C# 6 and later allows null checks to be simplified inline using a ? symbol before the . operator, as shown in the following code: Shout?.Invoke(this, EventArgs.Empty); 2. In the PeopleApp project, add a new class file named Program.EventHandlers.cs. Program.EventHandlers.cs, delete any existing statements, and then add a method with a 3. In matching signature that gets a reference to the Person object from the sender parameter and outputs some information about them, as shown in the following code: using Packt.Shared; // To use Person. // No namespace declaration so this extends the Program class // in the null namespace. partial class Program { // A method to handle the Shout event received by the harry object. private static void Harry_Shout(object? sender, EventArgs e) { // If no sender, then do nothing. if (sender is null) return; // If sender is not a Person, then do nothing. if (sender is not Person p) return; 