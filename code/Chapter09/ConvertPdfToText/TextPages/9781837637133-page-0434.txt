Chapter 9 401 With AMQP, messages are published to exchanges, which then distribute message copies to queues using rules named bindings. Then a broker can deliver the messages to consumers subscribed to a queue (sometimes called a topic) or a consumer can read from a queue when they want. Since networks and systems often fail, AMQP uses message acknowledgments to tell the broker when a consumer has successfully processed a message, and only then does the broker remove the message from the queue. RabbitMQ supports four types of exchange: • Direct: A direct exchange delivers messages based on a message routing key. Multiple queues can be bound to the exchange, but messages are only delivered to a queue if they have a matching routing key. They are mostly used for unicast messages. The default (empty name) exchange is a direct exchange. It is pre-bound with a routing key that is the same name as the queue. This is the type we will use in this book. Fanout: A fanout exchange delivers messages to all queues that are bound to it, and the routing • key is ignored. These are good for broadcasting messages. • Topic: A topic exchange delivers messages based on a routing key and criteria defined in the binding between the exchange and a queue. They are used for the publish/subscribe pattern, where there are many consumers but they want to receive different messages, based on factors like geographic location, registered interests, and so on. • Headers: A headers exchange delivers messages based on multiple attributes in a message header instead of a routing key. The RabbitMQ API uses the following types: IConnection: This represents an AMQP connection. • ConnectionFactory: This creates IConnection instances. It has default values for common • properties designed to work with the Docker image. For example, UserName is guest, Password is guest, VirtualHost is /, HostName is localhost, and Port is 5672. IModel: This represents the AMQP channel and has methods to perform common tasks, like • QueueDeclare or sending a message using BasicPublish. declaring a queue with IBasicConsumer: This represents a message consumer. • EventBasicConsumer: This is an implementation of a message consumer that integrates with • the .NET event system, making it easy for a client app to process a message as soon as it is sent and received. Good Practice: Queuing systems can get complicated fast. In this book, we will cover the basics, but if you decide to implement any queuing system in production, then you will want to learn much more about how to implement them deeply. You can install RabbitMQ locally on your computer, but for maximum ease of use, I recommend using a Docker image. 