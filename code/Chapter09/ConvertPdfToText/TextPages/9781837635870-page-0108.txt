Chapter 2 89 3. Run the code and note that the fourth statement cannot compile because the data type of the name variable is not known by the compiler, as shown in Figure 2.8: Figure 2.8: The object type does not have a Length property 4. Add double slashes to the beginning of the statement that cannot compile to comment out the statement, making it inactive. length of a string if the pro- 5. Run the code again and note that the compiler can access the grammer explicitly tells the compiler that the object variable contains a string by prefixing the name variable with a cast expression like (string)name. The results can then successfully be written to the console, as shown in the following output: Amir is 1.88 meters tall. Amir has 4 characters. You will learn about cast expressions in Chapter 3, Controlling Flow, Converting Types, and Handling Exceptions. The object type has been available since the first version of C#, but C# 2 and later have a better alter- native called generics, which we will cover in Chapter 6, Implementing Interfaces and Inheriting Classes. This will provide us with the flexibility we want but without the performance overhead. Storing dynamic types There is another special type named dynamic that can also store any type of data, but even more than object, its flexibility comes at the cost of performance. The dynamic keyword was introduced in C# 4. However, unlike object, the value stored in the variable can have its members invoked without an explicit cast. Letâ€™s make use of a dynamic type: 1. Add statements to declare a dynamic variable. Assign a string literal value, and then an integer value, and then an array of integer values. Finally, add a statement to output the length of the dynamic variable, as shown in the following code: dynamic something; // Storing an array of int values in a dynamic object. // An array of any type has a Length property. something = new[] { 3, 5, 7 }; 