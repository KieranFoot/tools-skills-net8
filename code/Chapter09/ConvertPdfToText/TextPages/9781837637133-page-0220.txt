Chapter 5 187 Stopwatch watch = Stopwatch.StartNew(); Task a = Task.Factory.StartNew(MethodA); Task b = Task.Factory.StartNew(MethodB); Task.WaitAll(new Task[] { a, b }); WriteLine(); WriteLine($"Results: {SharedObjects.Message}."); WriteLine($"{watch.ElapsedMilliseconds:N0} elapsed milliseconds."); 8. Run the code and view the result, as shown in the following output: Please wait for the tasks to complete. .......... Results: BABABAABBA. 5,753 elapsed milliseconds. This shows that both threads were modifying the message concurrently. In an actual application, this could be a problem. But we can prevent concurrent access by applying a mutually exclusive lock to a conch object, as well as adding code to the two methods to voluntarily check the conch before modifying the shared resource, which we will do in the following section. Applying a mutually exclusive lock to a conch Now, letâ€™s use a conch to ensure that only one thread accesses the shared resource at a time: 1. In SharedObjects.cs, declare and instantiate an object variable to act as a conch, as shown in the following code: public static object Conch = new(); // A shared object to lock. 2. In Program.Methods.cs, in both MethodA and MethodB, add a lock statement for the conch around the for statements, as shown highlighted in the following code for MethodB: lock (SharedObjects.Conch) { for (int i = 0; i < 5; i++) { Thread.Sleep(Random.Shared.Next(2000)); SharedObjects.Message += "B"; Write("."); } } 