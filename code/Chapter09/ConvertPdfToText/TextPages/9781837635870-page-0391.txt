Packaging and Distributing .NET Types 372 • Packages can ship on their own schedule. • Packages can be tested independently of other packages. Packages can support different OSes and CPUs by including multiple versions of the same • assembly built for different OSes and CPUs. • Packages can have dependencies specific to only one library. • Apps are smaller because unreferenced packages aren’t part of the distribution. Table 7.2 lists some of the more important packages and their important types: Package Important types System.Runtime Object, String, Int32, Array System.Collections List<T>, Dictionary<TKey, TValue> System.Net.Http HttpClient, HttpResponseMessage System.IO.FileSystem File, Directory System.Reflection Assembly, TypeInfo, MethodInfo Table 7.2: Some important packages and their important types Understanding frameworks There is a two-way relationship between frameworks and packages. Packages define the APIs, while frameworks group packages. A framework without any packages would not define any APIs. .NET packages each support a set of frameworks. For example, the System.IO.FileSystem package version 4.3.0 supports the following frameworks: • .NET Standard, version 1.3 or later • .NET Framework, version 4.6 or later • Six Mono and Xamarin platforms (for example, Xamarin.iOS) More Information: You can read the details at the following link: https://www.nuget. org/packages/System.IO.FileSystem/#supportedframeworks-body-tab. Importing a namespace to use a type Let’s explore how namespaces are related to assemblies and types: 1. In the AssembliesAndNamespaces project, in Program.cs, delete the existing statements and then enter the following code: XDocument doc = new(); 