Implementing Interfaces and Inheriting Classes 320 2. In Program.cs, add statements to sort the array using an alternative implementation, as shown in the following code: Array.Sort(people, new PersonComparer()); OutputPeopleNames(people, "After sorting using PersonComparer's IComparer implementation:"); 3. Run the PeopleApp project, and view the result of sorting the people by the length of their names and then alphabetically, as shown in the following output: After sorting using PersonComparer's IComparer implementation: Adam Jenny Simon Richard <null> Name <null> Person This time, when we sort the people array, we explicitly ask the sorting algorithm to use the PersonComparer type instead so that the people are sorted with the shortest names first, like Adam, and the longest names last, like Richard, and when the lengths of two or more names are equal they Jenny and Simon. are sorted alphabetically, like Implicit and explicit interface implementations Interfaces can be implemented implicitly and explicitly. Implicit implementations are simpler and more common. Explicit implementations are only necessary if a type must have multiple methods with the same name and signature. Personally, the only time I can remember ever having to explicitly implement an interface is when writing the code example for this book. For example, both IGamePlayer and IKeyHolder might have a method called Lose with the same parameters because both a game and a key can be lost. The members of an interface are always and public because they have to be accessible for another type to implement them! automatically In a type that must implement both interfaces, only one implementation of Lose can be the implicit method. If both interfaces can share the same implementation, there is no problem, but if not, then Lose method will have to be implemented differently and called explicitly, as shown in the the other following code: public interface IGamePlayer { void Lose(); } public interface IKeyHolder 