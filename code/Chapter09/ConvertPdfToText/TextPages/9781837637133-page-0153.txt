Building Entity Models for SQL Server Using EF Core 120 { options.UseSqlServer(connectionString); // Log to console when executing EF Core commands. options.LogTo(Console.WriteLine, new[] { Microsoft.EntityFrameworkCore .Diagnostics.RelationalEventId.CommandExecuting }); }, // Register with a transient lifetime to avoid concurrency // issues with Blazor Server projects. contextLifetime: ServiceLifetime.Transient, optionsLifetime: ServiceLifetime.Transient); return services; } } 6. Build the two class libraries and fix any compiler errors. Good Practice: We have provided an optional argument for the AddNorthwindContext method so that we can override the SQL Server database connection string. This will allow us more flexibility, for example, to load these values from a configuration file. Calculated properties on entity creation EF Core 7 added an IMaterializationInterceptor interface that allows interception before and after an entity is created, and when properties are initialized. This is useful for calculated values. For example, when a service or client app requests entities to show to the user, it might want to cache a copy of the entity for a period of time. To do this, it needs to know when the entity was last refreshed. It would be useful if this information was automatically generated and stored with each entity at the time of loading. To achieve this goal, we must complete four steps: 1. First, define an interface with the extra property. 2. Next, at least one entity model class must implement the interface. Then, define a class that implements the interceptor interface with a method named 3. InitializedInstance that will execute on any entity, and if that entity implements the cus- tom interface with the extra property, then it will set its value. 4. Finally, we must create an instance of the interceptor and register it in the data context class. 