Chapter 11 615 .Max(p => p.UnitPrice),10:$#,##0.00}"); WriteLine($"{"Sum of units in stock:",-25} {db.Products .Sum(p => p.UnitsInStock),10:N0}"); WriteLine($"{"Sum of units on order:",-25} {db.Products .Sum(p => p.UnitsOnOrder),10:N0}"); WriteLine($"{"Average unit price:",-25} {db.Products .Average(p => p.UnitPrice),10:$#,##0.00}"); WriteLine($"{"Value of units in stock:",-25} {db.Products .Sum(p => p.UnitPrice * p.UnitsInStock),10:$#,##0.00}"); } Good Practice: Getting a count can seem like a simple operation but count- ing can be costly. A DbSet<T> like Products does not have a Count property so TryGetNonEnumeratedCount returns false. A List<T> like products does have a Count property because it implements ICollection so TryGetNonEnumeratedCount returns true. (In this case, we had to instantiate a list, which is itself a costly operation, but if you already have a list and need to know the number of items, then this would be efficient.) You can always call Count() on a DbSet<T>, but it can be slow because it might have to enumerate the sequence depending on the data provider implementation. For any array, use the Length property to get a count. You can pass a lambda expression to Count() to filter which items in the sequence should be counted, which you cannot do with either the Count or Length properties. 2. In Program.cs, call the AggregateProducts method. 3. Run the code and view the result, as shown in the following output: Products DbSet does not have a Count property. Product count from list: 77 Product count: 77 Discontinued product count: 8 Highest product price: $263.50 Sum of units in stock: 3,119 Sum of units on order: 780 Average unit price: $28.87 Value of units in stock: $74,050.85 