Implementing Interfaces and Inheriting Classes 348 4. Run the PeopleApp project and view the result. Now, when the ToString method is called, it outputs the person’s name, as well as returning the base class’s implementation of ToString, as shown in the following output: John Jones is a Packt.Shared.Employee. Good Practice: Many real-world APIs, for example, Microsoft’s Entity Framework Core, Castle’s DynamicProxy, and Optimizely CMS’s content models, require the properties that you define in your classes to be marked as virtual so that they can be overridden. Care- fully decide which of your method and property members should be marked as virtual. Inheriting from abstract classes Earlier in this chapter, you learned about interfaces that can define a set of members that a type must have to meet a basic level of functionality. These are very useful, but their main limitation is that until C# 8 they could not provide any implementation of their own. This is a particular problem if you still need to create class libraries that will work with .NET Frame- work and other platforms that do not support .NET Standard 2.1. In those earlier platforms, you could use an abstract class as a sort of halfway house between a pure interface and a fully implemented class. When a class is marked as abstract, this means that it cannot be instantiated because you have indicated that the class is not complete. It needs more implementation before it can be instantiated. For example, the System.IO.Stream class is abstract because it implements common functionality that all streams would need but is not complete, and therefore, it is useless without more implemen- new Stream(). tation that is specific to the type of stream, so you cannot instantiate it using Let’s compare the two types of interface and the two types of class, as shown in the following code: public interface INoImplementation // C# 1 and later. { void Alpha(); // Must be implemented by derived type. } public interface ISomeImplementation // C# 8 and later. { void Alpha(); // Must be implemented by derived type. void Beta() { // Default implementation; can be overridden. } } 