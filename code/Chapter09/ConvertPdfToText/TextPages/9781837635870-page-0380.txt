Chapter 6 361 3. In the PeopleApp project, in Program.cs, create an instance of each type, setting the initial Name value to Bob, and then modify the Name property to Bill. You will see the two types that are immutable after initialization because they will give the compiler error CS8852, as shown in the following code: C1 c1 = new() { Name = "Bob" }; c1.Name = "Bill"; C2 c2 = new(Name: "Bob"); c2.Name = "Bill"; // CS8852: Init-only property. S1 s1 = new() { Name = "Bob" }; s1.Name = "Bill"; S2 s2 = new(Name: "Bob"); s2.Name = "Bill"; S3 s3 = new(Name: "Bob"); s3.Name = "Bill"; // CS8852: Init-only property. 4. Note that record C1 is mutable and C2 is immutable. Note that S1 and S2 are mutable and S3 is immutable. 5. Comment out the two statements that cause compiler errors. Microsoft made some interesting design choices with records. Make sure you remember the subtle differences in behavior when combining record, class, struct, and using different types of declaration of each. Comparing inheritance and implementation For me, the terms inherit and implement are different, and in the early days of C# and .NET you could FileStream class inherits strictly apply them to classes and interfaces respectfully. For example, the from the Stream class, and the Int32 struct implements the IComparable interface. Inherit implies some functionality that a subclass gets “for free” by inheriting from its base aka super class. Implement implies some functionality that is NOT inherited but instead MUST be provided by the subclass. This is why I chose to title this chapter Implementing Interfaces and Inheriting Classes. Before C# 8, interfaces were always purely contracts. There was no functionality in an interface that you could inherit. In those days, you could strictly use the term implement for interfaces that represent a list of members that your type must implement, and use the term inherit for classes with functionality that your type can inherit and potentially override. 