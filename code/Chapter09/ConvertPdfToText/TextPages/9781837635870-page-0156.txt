Chapter 3 137 It is used to perform a block of statements on each item in a sequence, for example, an array or col- lection. Each item is usually read-only, and if the sequence structure is modified during iteration, for example, by adding or removing an item, then an exception will be thrown. Try the following example: 1. Type statements to create an array of string variables and then output the length of each one, as shown in the following code: string[] names = { "Adam", "Barry", "Charlie" }; foreach (string name in names) { WriteLine($"{name} has {name.Length} characters."); } 2. Run the code and view the results, as shown in the following output: Adam has 4 characters. Barry has 5 characters. Charlie has 7 characters. Understanding how foreach works internally A developer who defines a type that represents multiple items, like an array or collection, should make sure that a programmer can use the foreach statement to enumerate through the type’s items. Technically, the foreach statement will work on any type that follows these rules: • The type must have a method named GetEnumerator that returns an object. Current and a method named MoveNext. • The returned object must have a property named MoveNext method must change the value of Current and return true if there are more • The items to enumerate through or return false if there are no more items. There are interfaces named IEnumerable and IEnumerable<T> that formally define these rules, but technically the compiler does not require the type to implement these interfaces. The compiler turns the foreach statement in the preceding example into something like the following pseudocode: IEnumerator e = names.GetEnumerator(); while (e.MoveNext()) { string name = (string)e.Current; // Current is read-only! WriteLine($"{name} has {name.Length} characters."); } 