Writing, Debugging, and Testing Functions 222 Throwing exceptions using guard clauses Instead of instantiating an exception using new, you can use static methods on the exception itself. When used in a function implementation to check argument values, they are known as guard clauses. Some were introduced with .NET 6, and more were added in .NET 8. Common guard clauses are shown in Table 4.4: Exception Guard clause methods ArgumentException ThrowIfNullOrEmpty, ThrowIfNullOrWhiteSpace ArgumentNullException ThrowIfNull ArgumentOutOfRangeException ThrowIfEqual, ThrowIfGreaterThan, ThrowIfGreaterThanOrEqual, ThrowIfLessThan, ThrowIfLessThanOrEqual, ThrowIfNegative, ThrowIfNegativeOrZero, ThrowIfNotEqual, ThrowIfZero Table 4.4: Common guard clauses Instead of writing an if statement and then throwing a new exception, we can simplify the previous example, as shown in the following code: static void Withdraw(string accountName, decimal amount) { ArgumentException.ThrowIfNullOrWhiteSpace(accountName, paramName: nameof(accountName)); ArgumentOutOfRangeException.ThrowIfNegativeOrZero(amount, paramName: nameof(amount)); // process parameters } Understanding the call stack The entry point for a .NET console application is the Main method (if you have explicitly defined this class) or <Main>$ (if it was created for you by the top-level program feature) in the Program class. The Main method will call other methods, which call other methods, and so on, and these methods could be in the current project or referenced projects and NuGet packages, as shown in Figure 4.24: Figure 4.24: A chain of method calls that create a call stack 