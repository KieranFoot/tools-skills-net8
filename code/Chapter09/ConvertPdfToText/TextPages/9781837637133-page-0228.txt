Chapter 5 195 yield return r.Next(1, 1001); await Task.Delay(r.Next(1500, 3000)); yield return r.Next(1, 1001); } } 5. In Program.cs, delete the existing statements and then add statements to enumerate the se- quence of numbers, as shown in the following code: // Use async streams to iterate over a collection asynchronously. await foreach (int number in GetNumbersAsync()) { WriteLine($"Number: {number}"); } 6. Run the code and view the result, as shown in the following output: Number: 509 Number: 813 Number: 307 Improving responsiveness for GUI apps So far in this book, we have only built console apps. Life for a programmer gets more complicated when building web applications, web services, and apps with GUIs such as Windows desktop and mobile apps. One reason for this is that for a GUI app, there is a special thread: the user interface (UI) thread. There are two rules for working in GUIs: • Do not perform long-running tasks on the UI thread. • Do not access UI elements on any thread except the UI thread. To handle these rules, programmers used to have to write complex code to ensure that long-running tasks were executed by a non-UI thread, but once complete, the results of the task were safely passed to the UI thread to present to the user. It could quickly get messy! Luckily, with C# 5 and later, you have the use of async and await. They allow you to continue to write your code as if it is synchronous, which keeps your code clean and easy to understand, but underneath, the C# compiler creates a complex state machine and keeps track of running threads. It’s kind of magical! The combination of these two keywords makes the asynchronous method run on a worker thread and, when it’s complete, return the results on the UI thread. Let’s see an example. We will build a Windows desktop app using Windows Presentation Foundation (WPF) that gets employees from the Northwind database in a SQL Server database using low-level types like SqlConnection, SqlCommand, and SqlDataReader. 