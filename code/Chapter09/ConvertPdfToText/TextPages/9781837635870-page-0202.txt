Chapter 4 183 We will write a function named Factorial; this will calculate the factorial for an int passed to it as a parameter. We will use a clever technique called recursion, which means a function that calls itself within its implementation, either directly or indirectly: 1. In Program.Functions.cs, write a function named Factorial, as shown in the following code: static int Factorial(int number) { if (number < 0) { throw new ArgumentOutOfRangeException(message: $"The factorial function is defined for non-negative integers only. Input: {number}", paramName: nameof(number)); } else if (number == 0) { return 1; } else { return number * Factorial(number - 1); } } As before, there are several noteworthy elements in the preceding code, including the following: • If the input parameter number is negative, Factorial throws an exception. number is zero, Factorial returns 1. • If the input parameter If the input parameter number is more than 0 (which it will be in all other cases), • Factorial multiplies the number by the result of calling itself and passing one less than number. This makes the function recursive. More Information: Recursion is clever, but it can lead to problems, such as a stack overflow due to too many function calls because memory is used to store data on every function call, and it eventually uses too much. Iteration is a more practical, if less succinct, solution in languages such as C#. You can read more about this at the following link: https://en.wikipedia.org/wiki/Recursion_(computer_ science)#Recursion_versus_iteration. 