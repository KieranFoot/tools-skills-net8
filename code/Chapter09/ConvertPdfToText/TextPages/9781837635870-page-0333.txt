Implementing Interfaces and Inheriting Classes 314 Comparing objects when sorting One of the most common interfaces that you will want to implement in your types that represent data is IComparable. If a type implements one of the IComparable interfaces, then arrays and collections containing instances of that type can be sorted. This is an example of an abstraction for the concept of sorting. To sort any type, the minimum func- tionality would be the ability to compare two items and decide which goes before the other. If a type implements that minimum functionality, then a sorting algorithm can use it to sort instances of that type in any way the sorting algorithm wants to. The IComparable interface has one method named CompareTo. This has two variations, one that works with a nullable object type and one that works with a nullable generic type T, as shown in the following code: namespace System { public interface IComparable { int CompareTo(object? obj); } public interface IComparable<in T> { int CompareTo(T? other); } } The in keyword specifies that the type parameter T is contravariant, which means that you can use a less derived type than that specified. For example, if Employee derives from Person, then both can be compared with each other. For example, the string type implements IComparable by returning -1 if the string should be sorted before the string being compared to, 1 if it should be sorted after, and 0 if they are equal. The int type implements IComparable by returning -1 if the int is less than the int being compared to, 1 if 0 if they are equal. it is greater, and CompareTo return values can be summarized as shown in Table 6.2: this before other this is equal to other this after other -1 0 1 Table 6.2: Summary of the CompareTo return values 