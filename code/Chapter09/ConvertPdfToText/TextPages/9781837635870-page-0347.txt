Implementing Interfaces and Inheriting Classes 328 4. Run the PeopleApp project and view the result, as shown in the following output: p1: Packt.Shared.Person, p2: Packt.Shared.Person p1.Name: Kevin, p2.Name: Kevin p1 == p2: False This is because they are not the same object. If both variables literally pointed to the same object on the heap, then they would be equal. 5. Add statements to declare a third Person object and assign p1 to it, as shown in the following code: Person p3 = p1; WriteLine($"p3: {p3}"); WriteLine($"p3.Name: {p3.Name}"); WriteLine($"p1 == p3: {p1 == p3}"); 6. Run the PeopleApp project and view the result, as shown in the following output: p3: Packt.Shared.Person p3.Name: Kevin p1 == p3: True The one exception to this behavior of reference types is the string type. It is a reference type, but the equality operators have been overridden to make them behave as if they were value types. 7. Add statements to compare the Name properties of two Person instances, as shown in the following code: // string is the only class reference type implemented to // act like a value type for equality. WriteLine($"p1.Name: {p1.Name}, p2.Name: {p2.Name}"); WriteLine($"p1.Name == p2.Name: {p1.Name == p2.Name}"); 8. Run the PeopleApp project and view the result, as shown in the following output: p1.Name: Kevin, p2.Name: Kevin p1.Name == p2.Name: True You can do the same as string with your classes to override the equality operator == to return true, even if the two variables are not referencing the same object (the same memory address on the heap) but, instead, their fields have the same values. However, that is beyond the scope of this book. 