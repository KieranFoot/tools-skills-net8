Controlling Flow, Converting Types, and Handling Exceptions 156 WriteLine($"There are {count} eggs."); } else { WriteLine("I could not parse the input."); } 2. Run the code, enter 12, and view the result, as shown in the following output: How many eggs are there? 12 There are 12 eggs. 3. Run the code, enter twelve, and view the result, as shown in the following output: How many eggs are there? twelve I could not parse the input. You can also use methods of the System.Convert type to convert string values into other types; how- Parse method, it gives an error if it cannot convert. ever, like the Understanding the Try method naming convention .NET uses a standard signature for all methods that follow the Try naming convention. For any method named Something that returns a value of a specific type, its matching TrySomething method must return a bool to indicate success or failure and use an out parameter in place of the return value. For example: // A method that might throw an exception. int number = int.Parse("123"); // The Try equivalent of the method. bool success = int.TryParse("123", out int number); // Trying to create a Uri for a Web API. bool success = Uri.TryCreate("https://localhost:5000/api/customers", UriKind.Absolute, out Uri serviceUrl); Handling exceptions Youâ€™ve seen several scenarios where errors have occurred when converting types. Some languages return error codes when something goes wrong. .NET uses exceptions that are richer and designed only for failure reporting. When this happens, we say a runtime exception has been thrown. Other systems might use return values that could have multiple uses. For example, if the return value is a positive number, it might represent the count of rows in a table, or if the return value is a negative number, it might represent some error code. 