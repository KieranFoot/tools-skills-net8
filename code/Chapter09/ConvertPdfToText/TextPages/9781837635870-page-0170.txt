Chapter 3 151 { for (int y = 0; y < 3; y++) { Write($"| {doubles[x, y],6} | {ToInt32(doubles[x, y]),7} "); } WriteLine("|"); } WriteLine(); 2. Run the code and view the result, as shown in the following output: | double | ToInt32 | double | ToInt32 | double | ToInt32 | | 9.49 | 9 | 9.5 | 10 | 9.51 | 10 | | 10.49 | 10 | 10.5 | 10 | 10.51 | 11 | | 11.49 | 11 | 11.5 | 12 | 11.51 | 12 | | 12.49 | 12 | 12.5 | 12 | 12.51 | 13 | | -12.49 | -12 | -12.5 | -12 | -12.51 | -13 | | -11.49 | -11 | -11.5 | -12 | -11.51 | -12 | | -10.49 | -10 | -10.5 | -10 | -10.51 | -11 | | -9.49 | -9 | -9.5 | -10 | -9.51 | -10 | We have shown that the rule for rounding in C# is subtly different from the primary school rule: • It always rounds toward zero if the decimal part is less than the midpoint .5. • It always rounds away from zero if the decimal part is more than the midpoint .5. • It will round away from zero if the decimal part is the midpoint .5 and the non-decimal part is odd, but it will round toward zero if the non-decimal part is even. This rule is known as Banker’s rounding, and it is preferred because it reduces bias by alternating when it rounds toward or away from zero. Sadly, other languages such as JavaScript use the primary school rule. Taking control of rounding rules You can take control of the rounding rules by using the Round method of the Math class: 1. Type statements to round each of the double values using the “away from zero” rounding rule, also known as rounding “up,” and then write the result to the console, as shown in the following code: foreach (double n in doubles) { WriteLine(format: "Math.Round({0}, 0, MidpointRounding.AwayFromZero) is {1}", arg0: n, 