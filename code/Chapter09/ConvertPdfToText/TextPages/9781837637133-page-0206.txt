5 Multitasking and Concurrency This chapter is about allowing multiple actions to occur at the same time to improve performance, scalability, and user productivity for the applications that you build. In this chapter, we will cover the following topics: • Understanding processes, threads, and tasks • Running tasks asynchronously • Synchronizing access to shared resources async and await • Understanding Understanding processes, threads, and tasks A process, with one example being each of the console applications we have created, has resources like memory and threads allocated to it. A thread executes your code statement by statement. By default, each process only has one thread, and this can cause problems when we need to do more than one task at the same time. Threads are also responsible for keeping track of things like the currently authenticated user and any internation- alization rules that should be followed for the current language and region. Windows and most other modern operating systems use preemptive multitasking, which simulates the parallel execution of tasks. It divides the processor time among the threads, allocating a time slice to each thread one after another. The current thread is suspended when its time slice finishes. The processor then allows another thread to run for a time slice. When Windows switches from one thread to another, it saves the context of the thread and reloads the previously saved context of the next thread in the thread queue. This takes both time and resources to complete. As a developer, if you have a small number of complex pieces of work and you want complete control over them, then you could create and manage individual Thread instances. If you have one main thread and multiple small pieces of work that can be executed in the background, then you can use the ThreadPool class to add delegate instances that point to those pieces of work implemented as methods to a queue, and they will be automatically allocated to threads in the thread pool. 