Chapter 10 525 Environment.CurrentDirectory, databaseFile); string connectionString = $"Data Source={path}"; WriteLine($"Connection: {connectionString}"); optionsBuilder.UseSqlite(connectionString); } } 5. In Program.cs, delete the existing statements. Then, import the Northwind.EntityModels namespace and output the database provider, as shown in the following code: using Northwind.EntityModels; // To use Northwind. using NorthwindDb db = new(); WriteLine($"Provider: {db.Database.ProviderName}"); // Disposes the database context. 6. Run the console app and note the output showing the database connection string and which database provider you are using, as shown in the following output: Connection: Data Source=C:\cs12dotnet8\Chapter10\WorkingWithEFCore\bin\ Debug\net8.0\Northwind.db Provider: Microsoft.EntityFrameworkCore.Sqlite You now know how to connect to a database by defining an EF Core data context. Next, we need to define a model that represents the tables in the database. Defining EF Core models EF Core uses a combination of conventions, annotation attributes, and Fluent API statements to build an entity model at runtime, which enables any actions performed on the classes to later be automatically translated into actions performed on the actual database. An entity class represents the structure of a table, and an instance of the class represents a row in that table. First, we will review the three ways to define a model, with code examples, and then we will create some classes that implement those techniques. Using EF Core conventions to define the model The code we will write will use the following conventions: • The name of a table is assumed to match the name of a DbSet<T> property in the DbContext class, for example, Products. • The names of the columns are assumed to match the names of properties in the entity model ProductId. class, for example, string .NET type is assumed to be a nvarchar type in the database. • The int .NET type is assumed to be an int type in the database. • The 