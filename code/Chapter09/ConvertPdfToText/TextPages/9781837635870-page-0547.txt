Working with Data Using Entity Framework Core 528 ) REFERENCES Suppliers (SupplierId), CONSTRAINT CK_Products_UnitPrice CHECK (UnitPrice >= 0), CONSTRAINT CK_ReorderLevel CHECK (ReorderLevel >= 0), CONSTRAINT CK_UnitsInStock CHECK (UnitsInStock >= 0), CONSTRAINT CK_UnitsOnOrder CHECK (UnitsOnOrder >= 0) ); In a Product class, we could apply attributes to specify this, as shown in the following code: [Required] [StringLength(40)] public string ProductName { get; set; } When there isnâ€™t an obvious map between .NET types and database types, an attribute can be used. For example, in the database, the column type of UnitPrice for the Products table is money. .NET does not have a money type, so it should use decimal instead, as shown in the following code: [Column(TypeName = "money")] public decimal? UnitPrice { get; set; } Using the EF Core Fluent API to define the model The last way that the model can be defined is by using the Fluent API. This API can be used instead of attributes, as well as being used in addition to them. For example, to define the ProductName property, instead of decorating the property with two attributes, an equivalent Fluent API statement could be written in the OnModelCreating method of the database context class, as shown in the following code: modelBuilder.Entity<Product>() .Property(product => product.ProductName) .IsRequired() .HasMaxLength(40); This keeps the entity model class simpler. Understanding data seeding with the Fluent API Another benefit of the Fluent API is to provide initial data to populate a database. EF Core automatically works out what insert, update, or delete operations must be executed. For example, if we wanted to make sure that a new database has at least one row in the Product table, then we would call the HasData method, as shown in the following code: modelBuilder.Entity<Product>() .HasData(new Product { ProductId = 1, 