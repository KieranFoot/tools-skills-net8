Writing, Debugging, and Testing Functions 228 3. Remove the ex by replacing the statement throw ex; with throw;. 4. Run the console app and note that the output includes all the details of the call stack. Implementing the tester-doer and try patterns The tester-doer pattern can avoid some thrown exceptions (but not eliminate them completely). This pattern uses pairs of functions: one to perform a test and the other to perform an action that would fail if the test was not passed. .NET implements this pattern itself. For example, before adding an item to a collection by calling the Add method, you can test to see if it is read-only, which would cause Add to fail and, therefore, throw an exception. For example, before withdrawing money from a bank account, you might test that the account is not overdrawn, as shown in the following code: if (!bankAccount.IsOverdrawn()) { bankAccount.Withdraw(amount); } The tester-doer pattern can add performance overhead, so you can also implement the try pattern, which, in effect, combines the test and do parts into a single function, as we saw with TryParse. Another problem with the tester-doer pattern occurs when you are using multiple threads. In this scenario, one thread calls the test function and it returns a value that indicates that it is okay to pro- ceed. But then another thread executes, which changes the state. Then the original thread continues executing, assuming that everything is fine, but it is not fine. This is called a race condition. This topic is too advanced to cover how to handle it in this book. Good Practice: Use the try pattern in preference to the tester-doer pattern. If you implement your own try pattern function and it fails, remember to set the out parameter to the false, as shown in the following code: default value of its type and then return static bool TryParse(string? input, out Person value) { if (someFailure) { value = default(Person); return false; } 