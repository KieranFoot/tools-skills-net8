Caching, Queuing, and Resilient Background Services 414 12. In Docker Desktop, note the container is gone from the list, but the image remains for quicker use next time. More Information: You can read more about using RabbitMQ with .NET at the following link: https://www.rabbitmq.com/dotnet-api-guide.html. The combination of caching, queuing, and handling transient faults goes a long way to making your services more resilient, scalable, and performant. In the last section of this chapter, we will look at long-running background services. Implementing long-running background services It is common to need long-running background services to perform operations like: • Performing a task on a regular timed schedule. • Processing queued messages. • Performing intense work like building AI and ML models or processing video and images. In the distant past, on the Windows operating system, to have some code running in the background meant building a Windows Service. For example, the database engine of SQL Server is implemented as a Windows Service. With the move to cross-platform, .NET needs a cross-platform solution to run code in the background. Background services often do not have a user interface, although they might provide one for the configuration and management of the service. Building a worker service Now, let’s build a worker service project so that we can see how we would host a long-running back- ground service: 1. Use your preferred code editor to add a new project, as defined in the following list: • Project template: Worker Service / worker • Solution file and folder: Chapter09 • Project file and folder: Northwind.Background.Workers • Enable Docker: Cleared • Do not use top-level statements: Cleared • Enable native AOT publish: Cleared Northwind.Background.Workers project file, note that the .NET SDK is Microsoft.NET. 2. In the , and then make the following changes, as highlighted in the following markup: Sdk.Worker • Treat warnings as errors. • Add a package reference for RabbitMQ. 