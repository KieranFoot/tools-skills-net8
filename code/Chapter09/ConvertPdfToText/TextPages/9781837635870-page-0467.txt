Working with Common .NET Types 448 For example, word processors use a stack to remember the sequence of actions you have recently performed, and then when you press Ctrl + Z, it will undo the last action in the stack, and then the next-to-last action, and so on. Queues are a good choice when you want to implement first-in, first-out (FIFO) behavior. With a queue, you can only directly access or remove the item at the front of the queue, although you can enumerate to read through the whole queue of items. You cannot, for example, directly access the second item in a queue. For example, background processes use a queue to process work items in the order that they arrive, just like people standing in line at the post office. .NET 6 introduced the PriorityQueue, where each item in the queue has a priority value assigned, as well as its position in the queue. Letâ€™s explore example code for queues: 1. In Program.cs, add some statements to illustrate some of the common ways of working with queues, for example, handling customers in a queue for coffee, as shown in the following code: Queue<string> coffee = new(); coffee.Enqueue("Damir"); // Front of the queue. coffee.Enqueue("Andrea"); coffee.Enqueue("Ronald"); coffee.Enqueue("Amin"); coffee.Enqueue("Irina"); // Back of the queue. OutputCollection("Initial queue from front to back", coffee); // Server handles next person in queue. string served = coffee.Dequeue(); WriteLine($"Served: {served}."); // Server handles next person in queue. served = coffee.Dequeue(); WriteLine($"Served: {served}."); OutputCollection("Current queue from front to back", coffee); WriteLine($"{coffee.Peek()} is next in line."); OutputCollection("Current queue from front to back", coffee); 2. Run the code and view the result, as shown in the following output: Initial queue from front to back: Damir 