Chapter 5 191 Good Practice: Is it good or bad that some developers use locks in event handling? Well, it is complicated. It depends on complex factors so I cannot give a value judgement. You can read more about events and thread safety at the following link: https://learn. microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered- harmful. But it is complicated, as explained by Stephen Cleary in the following blog post: https://blog.stephencleary.com/2009/06/threadsafe-events.html. Making CPU operations atomic Atomic is from the Greek word atomos, which means undividable. It is important to understand which operations are atomic in multithreading because if they are not atomic, then they could be interrupted by another thread partway through their operation. Is the C# increment operator atomic, as shown in the following code? int x = 3; x++; // is this an atomic CPU operation? It is not atomic! Incrementing an integer requires the following three CPU operations: 1. Load a value from an instance variable into a register. 2. Increment the value. 3. Store the value in the instance variable. A thread could be interrupted after executing the first two steps. A second thread could then execute all three steps. When the first thread resumes execution, it will overwrite the value in the variable, and the effect of the increment or decrement performed by the second thread will be lost! Interlocked that can perform atomic actions like Add, Increment, Decrement, There is a type named Exchange, CompareExchange, And, Or, and Read on the integer types in the following list: • System.Int32 (int), System.UInt32 (uint) System.Int64 (long), System.UInt64 (ulong) • Interlocked does not work on numeric types like byte, sbyte, short, ushort, and decimal. Interlocked can perform atomic operations like Exchange and CompareExchange that swap values in memory on the following types: • System.Single (float), System.Double (double) nint, nuint • • System.Object (object) Let’s see it in action: 1. Declare another field in the SharedObjects class that will count how many operations have occurred, as shown in the following code: public static int Counter; // Another shared resource. 