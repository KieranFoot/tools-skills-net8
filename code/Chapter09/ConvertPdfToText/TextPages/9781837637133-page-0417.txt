Caching, Queuing, and Resilient Background Services 384 .Deserialize<Product[]?>(cachedValueBytes); if (cachedValue is null) { cachedValue = GetDiscontinuedProductsFromDatabase(); } } return cachedValue ?? Enumerable.Empty<Product>(); } Unlike the in-memory cache that can store any live object, objects stored in dis- tributed cache implementations must be serialized into byte arrays because they need to be transmittable across networks. 6. Start the web service project, using the https profile without debugging. 7. Arrange the windows so that you can see the command prompt or terminal at the same time as the web page. 8. On the Swagger web page, click GET /api/product/discontinued to expand that section. 9. Click the Try it out button. 10. Click the Execute button, and note in the output that EF Core executes a SQL statement to get the products. 11. Click Execute within five seconds, continue to click it a few more times, and note that EF Core does not need to re-execute the SQL statement because the products are cached. If something reads them within a five-second sliding expiration, they will stay in memory forever. 12. Wait at least five seconds. Click Execute, and note in the output that EF Core executes a SQL statement to get the products 13. because they have not been read within the five-second sliding expiration window. 14. Continue to click Execute repeatedly, and note that after 20 seconds, EF Core must execute a SQL statement to refresh the products. 15. Close the browser and shut down the web server. A new abstraction for distributed caching The ASP.NET Core team is working on adding a new abstraction for distributed caching to make it easier to use. It is not expected to be ready for .NET 8. It might be included in a point release, like 8.1, but more likely will be built-in with .NET 9. Some GetAsync extension methods and supporting methods have been written by Marc Gravell. He maintains the most popular package to integrate .NET with Redis, so he has a lot of experience with distributed caching. 