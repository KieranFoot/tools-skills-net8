Using Popular Third-Party Libraries 238 3. Run the tests and note the date/time test fails, as shown in the following output: Expected when <2024-03-25 09:30:00> to be at least 2h before <2024-03-25 11:00:00>, but it is behind by 1h and 30m. 4. For the due variable, change the hour from 11 to 13. 5. Run the tests and note that the date/time test succeeds. More Information: You can learn more details about FluentAssertions at the following link: https://fluentassertions.com/. Validating data FluentValidation allows you to define strongly typed validation rules in a human-readable way. You create a validator for a type by inheriting from AbstractValidator<T>, where T is the type that you want to validate. In the constructor, you call the RuleFor method to define one or more rules. If When method. a rule should run only in specified scenarios, then you call the Understanding the built-in validators FluentValidation ships with lots of useful built-in validator extension methods for defining rules, as shown in the following partial list, some of which you will explore in the coding task in this section: • Null, NotNull, Empty, NotEmpty • Equal, NotEqual • Length, MaxLength, MinLength • LessThan, LessThanOrEqualTo, GreaterThan, GreaterThanOrEqualTo • InclusiveBetween, ExclusiveBetween • ScalePrecision • Must (aka predicate) Matches (aka regular expression), EmailAddress, CreditCard • • IsInEnum, IsEnumName Performing custom validation The easiest way to create custom rules is to use Predicate to write a custom validation function. You can also call the Custom method to get maximum control. Customizing validation messages There are a few extension methods that are used to customize the validation messages’ output when data fails to pass the rules: • WithName: Change the name used for a property in the message. 