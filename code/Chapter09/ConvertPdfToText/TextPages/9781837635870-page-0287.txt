Building Your Own Types with Object-Oriented Programming 268 In C# 7, both things would use the Item1 and Item2 naming schemes. In C# 7.1 and later, thing2 can infer the names Name and Count. Aliasing tuples The ability to alias a tuple was introduced in C# 12 so that you can name the type and use that as the type name when declaring variables and parameters, for example, as shown in the following code: using UnnamedParameters = (string, int); // Aliasing a tuple type. // Aliasing a tuple type with parameter names. using Fruit = (string Name, int Number); When aliasing tuples use the title case naming convention for its parameters, for example, Name, Number, and BirthDate. Letâ€™s see an example: 1. In Program.cs, at the top of the file, define a named tuple type, as shown in the following code: using Fruit = (string Name, int Number); // Aliasing a tuple type. 2. In Program.cs, copy and paste the statement that calls the GetNamedFruit method and change var to Fruit, as shown in the following code: // Without an aliased tuple type. //var fruitNamed = bob.GetNamedFruit(); // With an aliased tuple type. Fruit fruitNamed = bob.GetNamedFruit(); 3. Run the PeopleApp project and note the result is the same. Deconstructing tuples You can also deconstruct tuples into separate variables. The deconstructing declaration has the same syntax as named field tuples but without a named variable for the tuple, as shown in the following code: // Store return value in a tuple variable with two named fields. (string name, int number) namedFields = bob.GetNamedFruit(); // You can then access the named fields. WriteLine($"{namedFields.name}, {namedFields.number}"); // Deconstruct the return value into two separate variables. (string name, int number) = bob.GetNamedFruit(); // You can then access the separate variables. WriteLine($"{name}, {number}"); 