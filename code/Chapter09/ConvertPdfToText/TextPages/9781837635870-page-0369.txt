Implementing Interfaces and Inheriting Classes 350 Every member of an interface must be public (or at least match the interface’s access level, which could be internal if it should only be used in the class library that it’s defined in). An abstract class has more flexibility in its members’ access modifiers. Another advantage of an abstract class over an interface is that serialization often does not work for an interface. So, no, we still need to be able to define abstract classes. Preventing inheritance and overriding You can prevent another developer from inheriting from your class by applying the sealed keyword to its definition. For example, no one can inherit from Scrooge McDuck, as shown in the following code: public sealed class ScroogeMcDuck { } An example of sealed in .NET is the string class. Microsoft has implemented some extreme opti- mizations inside the string class that could be negatively affected by your inheritance, so Microsoft prevents that. You can prevent someone from further overriding a virtual method in your class by applying the sealed keyword to the method. For example, no one can change the way Lady Gaga sings, as shown in the following code: namespace Packt.Shared; public class Singer { // Virtual allows this method to be overridden. public virtual void Sing() { WriteLine("Singing..."); } } public class LadyGaga : Singer { // The sealed keyword prevents overriding the method in subclasses. public sealed override void Sing() { WriteLine("Singing with style..."); } } You can only seal an overridden method. 