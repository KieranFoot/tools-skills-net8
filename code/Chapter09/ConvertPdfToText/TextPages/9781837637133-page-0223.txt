Multitasking and Concurrency 190 } finally { Monitor.Exit(SharedObjects.Conch); } 2. Run the code and view the result, which should return the same results as before (although either A or B could grab the conch first) but is better code because it will prevent potential deadlocks. Good Practice: Only use the lock keyword if you can write your code such that it avoids potential deadlocks. If you cannot avoid potential deadlocks, then al- ways use the Monitor.TryEnter method instead of lock, in combination with a try-finally statement, so that you can supply a timeout and one of the threads will back out of a deadlock if it occurs. You can read more about good threading practices at the following link: https://learn.microsoft.com/en-us/dotnet/ standard/threading/managed-threading-best-practices. Synchronizing events .NET events are not thread-safe, so you should avoid using them in multi-threaded scenarios. After learning that .NET events are not thread-safe, some developers attempt to use exclusive locks when adding and removing event handlers or when raising an event, as shown in the following code: // event delegate field public event EventHandler? Shout; // conch private object eventConch = new(); // method public void Poke() { lock (eventConch) // bad idea { // If something is listening... if (Shout != null) { // ...then call the delegate to raise the event. Shout(this, EventArgs.Empty); } } } 