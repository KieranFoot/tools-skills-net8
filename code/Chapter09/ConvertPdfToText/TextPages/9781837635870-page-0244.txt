Chapter 4 225 at System.IO.File.OpenText(String path) at CallStackExceptionHandlingLib.Calculator.Delta() in C:\cs11dotnet8\ Chapter04\CallStackExceptionHandlingLib\Processor.cs:line 16 at CallStackExceptionHandlingLib.Calculator.Gamma() in C:\cs12dotnet8\ Chapter04\CallStackExceptionHandlingLib\Processor.cs:line 10 at Program.<<Main>$>g__Beta|0_1() in C:\cs12dotnet8\Chapter04\ CallStackExceptionHandling\Program.cs:line 16 at Program.<<Main>$>g__Alpha|0_0() in C:\cs12dotnet8\Chapter04\ CallStackExceptionHandling\Program.cs:line 10 at Program.<Main>$(String[] args) in C:\cs12dotnet8\Chapter04\ CallStackExceptionHandling\Program.cs:line 5 Note that the call stack is upside-down. Starting from the bottom, you see: • The first call is to the <Main>$ entry point function in the auto-generated Program class. This is where arguments are passed in as a String array. The second call is to the <<Main>$>g__Alpha|0_0 function. (The C# compiler renames • it from Alpha when it adds it as a local function.) Beta function. • The third call is to the Gamma function. • The fourth call is to the Delta function. This function attempts to open a file by passing • The fifth call is to the a bad file path. This causes an exception to be thrown. Any function with a try-catch statement could catch this exception. If it does not, the exception is automatically passed up the call stack until it reaches the top, where .NET outputs the exception (and the details of this call stack). Good Practice: Unless you need to step through your code to debug it, you should always run your code without the debugger attached. In this case, it is especially important not to attach the debugger because, if you do, it will catch the exception and show it in a GUI dialog box instead of outputting it as shown in the book. Where to catch exceptions Programmers can decide if they want to catch an exception near the failure point or centralized higher up the call stack. This allows your code to be simplified and standardized. You might know that calling an exception could throw one or more types of exception, but you do not need to handle any of them at the current point in the call stack. Rethrowing exceptions Sometimes you want to catch an exception, log it, and then rethrow it. For example, if you are writ- ing a low-level class library that will be called from an application, your code may not have enough information to programmatically fix the error in a smart way, but the calling application might have more information and be able to. Your code should log the error in case the calling application does not, and then rethrow it up the call stack in case the calling application chooses to handle it better. 