Working with Data Using Entity Framework Core 570 INSERT INTO "Products" ("CategoryId", "UnitPrice", "Discontinued", "ProductName", "UnitsInStock") VALUES (@p0, @p1, @p2, @p3, @p4); SELECT "ProductId" FROM "Products" WHERE changes() = 1 AND "rowid" = last_insert_rowid(); State: Unchanged, ProductId: 78 Add product successful with ID: 78. | Id | Product Name | Cost | Stock | Disc. | | 001 | Chai | $18.00 | 39 | False | | 002 | Chang | $19.00 | 17 | False | ... | 078 | Bob's Burgers | $500.00 | 72 | False | When the new product is first created in memory and tracked by the EF Core change tracker, it has a state of Added and its ID is 0. After the call to SaveChanges, it has a state of Unchanged and its ID is 78, the value assigned by the database. Updating entities Now, let’s modify an existing row in a table. We will find a product to update by specifying the start of a product name and only return the first match. In a real application, if you need to update a specific product, then you must use a unique identifier like ProductId. I do not know what the product ID will be for the products that you add. I do know that there are no products that start with “Bob” in the existing Northwind database. Finding a product to update using its name avoids having to tell you to first discover what the prod- uct ID is for a product that you’ve added. It is likely to be 78 because there are already 77 products in the table, but once you’ve added that and then deleted it, the next product to be added would be 79 and it all gets out of sync. Let’s go: 1. In Program.Modifications.cs, add a method to increase the price of the first product with a Bob in our example) by a specified amount, name that begins with a specified value (we’ll use like $20, as shown in the following code: private static (int affected, int productId) IncreaseProductPrice( string productNameStartsWith, decimal amount) { using NorthwindDb db = new(); 