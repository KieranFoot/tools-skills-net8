Implementing Interfaces and Inheriting Classes 326 When the method completes, all the stack memory is automatically released from the top of the stack. However, heap memory could still be allocated after a method returns. It is the .NET runtime garbage collectorâ€™s responsibility to release this memory at a future date. Heap memory is not immediately released to improve performance. We will learn about the garbage collector later in this section. The console app might then call another method that needs some more stack memory to be allocat- ed to it, and so on. Stack memory is literally a stack: memory is allocated at the top of the stack and removed from there when it is no longer needed. C# developers do not have control over the allocation or release of memory. Memory is automatically allocated when methods are called, and that memory is automatically released when the method returns. This is known as verifiably safe code. C# developers can allocate and access raw memory using unsafe code. The stackalloc keyword is used to allocate a block of memory on the stack. Memory allocated is released automatically when the method that allocated it returns. This is an advanced feature not covered in this book. You can read about unsafe code and stackalloc at the following links: https://learn.microsoft.com/en- and https://learn.microsoft.com/en-us/ us/dotnet/csharp/language-reference/unsafe-code . dotnet/csharp/language-reference/operators/stackalloc Understanding boxing Boxing is nothing to do with being punched in the face, although for Unity game developers struggling to manage limited memory it can sometimes feel like it. Boxing in C# is when a value type is moved to heap memory and wrapped inside a System.Object instance. Unboxing is when that value is moved back onto the stack. Unboxing happens explicitly. Boxing happens implicitly, so it can happen without the developer realizing. Boxing can take up to 20 times longer than without boxing. For example, an int value can be boxed and then unboxed, as shown in the following code: int n = 3; object o = n; // Boxing happens implicitly. n = (int)o; // Unboxing only happens explicitly. A common scenario is passing value types to formatted strings, as shown in the following code: string name = "Hilda"; DateTime hired = new(2024, 2, 21); int days = 5; // hired and days are value types that will be boxed. Console.WriteLine("{0} hired on {1} for {2} days.", name, hired, days); The name variable is not boxed because string is a reference type and is therefore already on the heap. 