Multitasking and Concurrency 202 Common types that support multitasking There are many common types that have asynchronous methods that you can await, as shown in Table 5.4: Type Methods DbContext<T> AddAsync, AddRangeAsync, FindAsync, and SaveChangesAsync AddAsync, AddRangeAsync, ForEachAsync, SumAsync, ToListAsync DbSet<T> ToDictionaryAsync, AverageAsync, and CountAsync HttpClient GetAsync, PostAsync, PutAsync, DeleteAsync, and SendAsync StreamReader ReadAsync, ReadLineAsync, and ReadToEndAsync StreamWriter WriteAsync, WriteLineAsync, and FlushAsync Table 5.4: Common types with asynchronous methods Good Practice: Any time you see a method that ends in the Async suffix, check to see whether it returns Task or Task<T>. If it does return Task or Task<T>, then you could use it instead of the synchronous non-Async suffixed method. Remember to call it using await and decorate your method with async. Using await in catch blocks When async and await were first introduced in C# 5, it was only possible to use the await keyword try block, but not in a catch block. In C# 6 and later, it is now possible to use await in both try in a and catch blocks. Practicing and exploring Test your knowledge and understanding by answering some questions, getting some hands-on practice, and exploring this chapter’s topics with deeper research. Exercise 5.1 – Test your knowledge Answer the following questions: 1. What information can you find out about a process? Stopwatch class? 2. How accurate is the Task or Task<T>? 3. By convention, what suffix should be applied to a method that returns To use the await keyword inside a method, what keyword must be applied to the method 4. declaration? 5. How do you create a child task? lock keyword? 6. Why should you avoid the Interlocked class? 7. When should you use the Mutex class instead of the Monitor class? 8. When should you use the 