Querying and Manipulating Data Using LINQ 604 IQueryable<Product> filteredProducts = allProducts.Where(product => product.UnitPrice < 10M); IOrderedQueryable<Product> sortedAndFilteredProducts = filteredProducts.OrderByDescending(product => product.UnitPrice); WriteLine("Products that cost less than $10:"); foreach (Product p in sortedAndFilteredProducts) { WriteLine("{0}: {1} costs {2:$#,##0.00}", p.ProductId, p.ProductName, p.UnitPrice); } WriteLine(); } } Note the following about the preceding code: • DbSet<T> implements IEnumerable<T>, so LINQ can be used to query and manipulate sequences of entities in models built for EF Core. (Actually, I should say TEntity instead of T, but the name of this generic type has no functional effect. The only requirement is that the type is a class. The name just indicates the class is expected to be an entity model.) The sequences implement IQueryable<T> (or IOrderedQueryable<T> after a call to • an ordering LINQ method) instead of IEnumerable<T> or IOrderedEnumerable<T>. This is an indication that we are using a LINQ provider that builds the query using expression trees. They represent code in a tree-like data structure and enable the cre- ation of dynamic queries, which is useful for building LINQ queries for external data providers like SQLite. The LINQ expression will be converted into another query language, such as SQL. • Enumerating the query with foreach or calling a method such as ToArray will force the execution of the query and materialize the results. 5. In Program.cs, delete any existing statements and then call the ConfigureConsole and FilterAndSort methods, as shown in the following code: ConfigureConsole(); // Sets US English by default. FilterAndSort(); 6. Run the project and view the result, as shown in the following output: CurrentCulture: English (United States) *** Filter and sort *** SQLite database path: C:\cs12dotnet8\Chapter11\LinqWithEFCore\Northwind.db 