Implementing Interfaces and Inheriting Classes 354 You could simplify the code further using a declaration pattern, and this will avoid the need to perform an explicit cast, as shown in the following code: if (aliceInPerson is Employee explicitAlice) { WriteLine($"{nameof(aliceInPerson)} is an Employee."); // Safely do something with explicitAlice. } What if you want to execute a block of statements when Alice is not an employee? In the past, you would have had to use the ! (not) operator, as shown in the following code: if (!(aliceInPerson is Employee)) With C# 9 and later, you can use the not keyword, as shown in the following code: if (aliceInPerson is not Employee) Using as to cast a type Alternatively, you can use the as keyword to cast a type. Instead of throwing an exception, the as keyword returns null if the type cannot be cast: 1. In Program.cs, add statements to cast Alice using the as keyword, and then check whether the return value is not null, as shown in the following code: Employee? aliceAsEmployee = aliceInPerson as Employee; if (aliceAsEmployee is not null) { WriteLine($"{nameof(aliceInPerson)} as an Employee."); // Safely do something with aliceAsEmployee. } Since accessing a member of a null variable will throw a NullReferenceException error, you should always check for null before using the result. 2. Run the PeopleApp project and view the result, as shown in the following output: aliceInPerson as an Employee. Good Practice: Use the is and as keywords to avoid throwing exceptions when casting between derived types. If you donâ€™t do this, you must write try-catch statements for InvalidCastException. 